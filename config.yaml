# Configuration for Family Assistant

# Event system configuration
event_system:
  enabled: true
  storage:
    sample_interval_hours: 1.0  # Store 1 event per entity per hour
    max_event_size: 100000  # 100KB max event size
    retention_hours: 48
  sources:
    home_assistant:
      enabled: true
      # URL and token are shared with context provider

# LLM provider-specific parameters
# Keys can be full model names or prefixes (ending with '-')
# Parameters defined here will be passed as keyword arguments to litellm.completion
# for matching models.
llm_parameters:
  # Example for Gemini models via OpenRouter
  "openrouter/google/gemini-":
    reasoning: # Nest OpenRouter-specific reasoning params here
      effort: medium
    # Other top-level parameters for this model could still go here
    # temperature: 0.8
  # Example for another model type
  # "anthropic/claude-3-":
  #   temperature: 0.75
  #   top_k: 50

# Configuration for the document indexing pipeline
indexing_pipeline_config:
  # Optional global configurations for the pipeline itself, if IndexingPipeline supports them
  # global_pipeline_config:
  #   some_global_setting: value

  processors:
    - type: "TitleExtractor"
      # config: {} # No specific config for TitleExtractor in this example
    - type: "PDFTextExtractor"
      # config: {} # No specific config for PDFTextExtractor
    - type: "WebFetcher"
      config: # Specific config for WebFetcherProcessor
        # Scraper instance is injected by DocumentIndexer, not configured here
        # Default user agent or other WebFetcherProcessor specific settings could go here
        # e.g. max_content_length: 1000000
        {} # No specific config other than scraper injection for now
    - type: "LLMSummaryGenerator"
      config:
        # llm_client is injected by DocumentIndexer
        input_content_types:
          - "original_document_file"
          - "raw_body_text" # For emails, if used by this indexer
          - "extracted_markdown_content" # From PDFTextExtractor
          - "fetched_content_markdown" # From WebFetcherProcessor
        target_embedding_type: "llm_generated_summary"
        # max_content_length: 100000 # Example, if needed
    - type: "TextChunker"
      config:
        chunk_size: 1000
        chunk_overlap: 100
        embedding_type_prefix_map:
          # For content parts directly provided to DocumentIndexer
          raw_body_text: "content_chunk"
          raw_file_text: "content_chunk"
          raw_note_text: "content_chunk"  # From NotesIndexer
          # For content generated by other processors
          extracted_markdown_content: "content_chunk" # From PDFTextExtractor
          fetched_content_markdown: "content_chunk" # From WebFetcherProcessor
    - type: "EmbeddingDispatch"
      config:
        embedding_types_to_dispatch:
          - "title"
          # - "summary" # If you have a manual summary type
          - "content_chunk"
          - "llm_generated_summary" # From LLMSummaryGeneratorProcessor
          # Raw content types - will be embedded if small enough, stored if too large
          - "raw_note_text"
          - "raw_body_text"
          - "raw_file_text"
          - "extracted_markdown_content" # Full PDF text
          - "fetched_content_markdown" # Full web page content

# Other future configurations can go here
# e.g., web_server_port: 8080

# --- Calendar Configuration ---
# Calendar configuration is shared across all profiles.
# Populated from environment variables (CALDAV_*, ICAL_URLS).
# calendar_config:
#   caldav:
#     username: "user"
#     password: "password"
#     calendar_urls: ["url1"]
#   ical:
#     urls: ["url2"]

# --- Default Service Profile Configuration ---
# Settings for the primary, default assistant behavior.
default_profile_settings:
  processing_config:
    home_assistant_context_template: |-
      {# Macro to format a distance value (assumed to be in km by the distance() function) 
         into a user-friendly string with 'm' or 'km'. #}
      {%- macro get_formatted_distance_string(distance_value_km) -%}
        {%- if distance_value_km is number and distance_value_km < 1 -%}
          {{- (distance_value_km * 1000) | round(0) ~ " m" -}}
        {%- elif distance_value_km is number -%}
          {{- distance_value_km | round(1) ~ " km" -}}
        {%- else -%}
          {{- "" -}} {# Handle cases where distance might not be a number #}
        {%- endif -%}
      {%- endmacro -%}
      
      {# Macro to find the closest zone to a person and its distance.
         It populates the 'out_ns.result_dict' with a dictionary 
         containing {'zone_obj': <state_obj>, 'distance': <float>}, or sets it to none. #}
      {%- macro find_closest_zone_data(person_obj, out_ns) -%}
        {%- set zones_with_distances = namespace(list=[]) -%}
      
        {%- for zone_obj in states.zone | rejectattr('entity_id', 'equalto', 'zone.near_home') -%}
          {%- set current_dist = distance(zone_obj.entity_id, person_obj.entity_id) -%}
          {%- if current_dist is number -%}
            {%- set zones_with_distances.list = zones_with_distances.list + [{'zone_obj': zone_obj, 'distance': current_dist}] -%}
          {%- endif -%}
        {%- endfor -%}
      
        {%- if zones_with_distances.list -%}
          {%- set out_ns.result_dict = (zones_with_distances.list | sort(attribute='distance') | first) -%}
        {%- else -%}
          {%- set out_ns.result_dict = none -%}
        {%- endif -%}
        {# This macro modifies 'out_ns' by side effect and does not render its primary data as output. #}
      {%- endmacro -%}
      
      {# Macro to determine and return the detailed portion of a 'not_home' status message.
         For example: " 1.2 km from Work" or " (location data unavailable)". #}
      {%- macro get_not_home_status_details(person_obj) -%}
        {%- if state_attr(person_obj.entity_id, 'latitude') is not none and state_attr(person_obj.entity_id, 'longitude') is not none -%}
          {%- if states.zone | length > 0 -%}
            {# Create a namespace to hold the output from the find_closest_zone_data macro #}
            {%- set closest_zone_ns = namespace(result_dict=none) -%}
            {# Call the macro; it will populate closest_zone_ns.result_dict by side effect. #}
            {# Assigning to '_' signifies we're primarily interested in the side effect, not the macro's direct string output (which should be empty). #}
            {%- set _ = find_closest_zone_data(person_obj, closest_zone_ns) -%} 
            
            {%- set closest_zone_data = closest_zone_ns.result_dict -%} {# Retrieve the actual dictionary #}
      
            {%- if closest_zone_data is not none and closest_zone_data.distance is number -%}
              {{- " " ~ get_formatted_distance_string(closest_zone_data.distance) ~ " from " ~ closest_zone_data.zone_obj.name -}}
            {%- elif closest_zone_data is not none -%} {# A zone was found, but distance was invalid for formatting #}
              {{- " (could not calculate distance to " ~ closest_zone_data.zone_obj.name ~ ")" -}}
            {%- else -%}
              {{- " (unable to find a suitable closest zone)" -}}
            {%- endif -%}
          {%- else -%}
            {{- " (no zones defined)" -}}
          {%- endif -%}
        {%- else -%}
          {{- " (location data unavailable)" -}}
        {%- endif -%}
      {%- endmacro -%}
      
      {%- for person in states.person -%}
        {%- if not loop.first -%}{{ "\n" }}{%- endif -%} {# Ensures each person's status starts on a new line. #}
        
        {{- person.name -}}
        {%- if person.state == 'not_home' -%}
          {{- " is not home" ~ get_not_home_status_details(person) -}}
        {%- else -%}
          {# If not 'not_home', the person.state is the friendly name of the zone they are in. #}
          {{- " is at " ~ person.state -}}
        {%- endif -%}
        {%- set lat = state_attr(person.entity_id, 'latitude') -%}
        {%- set lon = state_attr(person.entity_id, 'longitude') -%}
        {%- if lat is not none and lon is not none -%}
          {{- " (" ~ lat ~ ", " ~ lon ~ ")" -}}
        {%- endif -%}
      {%- endfor -%}

      {% set forecasts = state_attr("sensor.electricity_price_forecast", "forecasts") or [] -%}
      {%- set significant_periods = [] -%}
      {# Use a namespace to allow modifying variables inside the loop #}
      {%- set current_period = namespace(start_time=none, end_time=none, type=none, raw_end_time_for_comparison=none) -%}

      {# Ensure forecasts are sorted by start_time, as processing relies on this order #}
      {%- for forecast in forecasts | sort(attribute='start_time') -%}
        {%- set descriptor = forecast.descriptor -%}
        {%- set f_start_time_str = forecast.start_time -%}
        {%- set f_end_time_str = forecast.end_time -%}
      
        {%- set forecast_type = namespace(value=none) -%}
        {%- if descriptor in ["extremely_low", "very_low"] -%}
          {%- set forecast_type.value = "very low" -%}
        {%- elif descriptor in ["high", "spike"] -%}
          {%- set forecast_type.value = "very high" -%}
        {%- endif -%}

        {%- if forecast_type.value -%}
          {#- This forecast is of interest (very low or very high price) -#}
          {%- if current_period.type == none -%}
            {#- No active significant period, so start a new one -#}
            {%- set current_period.start_time = f_start_time_str -%}
            {%- set current_period.raw_end_time_for_comparison = f_end_time_str -%}
            {%- set current_period.end_time = f_end_time_str -%}
            {%- set current_period.type = forecast_type.value -%}
            {%- set current_period.min = forecast.per_kwh -%}
            {%- set current_period.max = forecast.per_kwh -%}
          {%- elif current_period.type == forecast_type.value -%}
            {#- Current forecast is of the same significant type as the active period. Check for adjacency. -#}
            {#- Adjacency condition: current forecast's start_time should be very close to the active period's end_time. -#}
            {#- We use as_timestamp for robust comparison, allowing for small gaps (e.g., 1 second). -#}
            {%- set prev_end_ts = as_timestamp(current_period.raw_end_time_for_comparison) | default(0) -%}
            {%- set curr_start_ts = as_timestamp(f_start_time_str) | default(0) -%}

            {#- Consider adjacent if start is within ~5 seconds of previous end, and not before it. -#}
            {#- This threshold (5 seconds) can be adjusted based on data patterns. -#}
            {%- if curr_start_ts - prev_end_ts <= 5 and curr_start_ts >= prev_end_ts -%}
              {#- Adjacent and same type: extend the current period -#}
              {%- set current_period.raw_end_time_for_comparison = f_end_time_str -%}
              {%- set current_period.end_time = f_end_time_str -%}
              {%- set current_period.min = [current_period.min, forecast.per_kwh]|min -%}
              {%- set current_period.max = [current_period.max, forecast.per_kwh]|max -%}
            {%- else -%}
              {#- Not adjacent: finalize the old period and start a new one -#}
              {%- set significant_periods = significant_periods + [{
                  "type": current_period.type,
                  "start": current_period.start_time,
                  "end": current_period.end_time
                }] -%}
              {%- set current_period.start_time = f_start_time_str -%}
              {%- set current_period.raw_end_time_for_comparison = f_end_time_str -%}
              {%- set current_period.end_time = f_end_time_str -%}
              {%- set current_period.type = forecast_type.value -%}
              {%- set current_period.min = forecast.per_kwh -%}
              {%- set current_period.max = forecast.per_kwh -%}
            {%- endif -%}
          {%- else -%} 
            {# Different significant type (e.g., was "very high", now "very low"): finalize old, start new #}
            {%- set significant_periods = significant_periods + [{
                "type": current_period.type,
                "start": current_period.start_time,
                "end": current_period.end_time
              }] -%}
            {%- set current_period.start_time = f_start_time_str -%}
            {%- set current_period.raw_end_time_for_comparison = f_end_time_str -%}
            {%- set current_period.end_time = f_end_time_str -%}
            {%- set current_period.type = forecast_type.value -%}
            {%- set current_period.min = forecast.per_kwh -%}
            {%- set current_period.max = forecast.per_kwh -%}
          {%- endif -%}
        {%- else -%}
          {#- Forecast is not of interest (e.g., neutral, low) -#}
          {%- if current_period.type != none -%}
            {#- A significant period was active, finalize it -#}
            {%- set significant_periods = significant_periods + [{
                "type": current_period.type,
                "start": current_period.start_time,
                "end": current_period.end_time,
                "min": current_period.min,
                "max": current_period.max,
              }] -%}
            {%- set current_period.start_time = none -%}
            {%- set current_period.raw_end_time_for_comparison = none -%}
            {%- set current_period.end_time = none -%}
            {%- set current_period.type = none -%}
            {%- set current_period.min = none -%}
            {%- set current_period.max = none -%}
          {%- endif -%}
        {%- endif -%}
      {%- endfor -%}

      {# After the loop, finalize any period that was still active #}
      {%- if current_period.type != none -%}
        {%- set significant_periods = significant_periods + [{
            "type": current_period.type,
            "start": current_period.start_time,
            "end": current_period.end_time
          }] -%}
      {%- endif %}

      ## Energy price
      Currently: {{ states("sensor.general_price") }} ({{ state_attr("sensor.general_price", "descriptor") }})
      
      {% if significant_periods -%}
        {%- for period in significant_periods %}
      Price is {{ period.type }} ({{ period.min }} to {{ period.max }}) from {{ period.start | as_datetime | as_local }} to {{ period.end | as_datetime | as_local }}
        {%- endfor -%}
      {%- else -%}
      No very high or very low energy price periods are forecast.
      {%- endif -%}
    # `prompts` are loaded from prompts.yaml. This key is a placeholder for that structure.
    # prompts:
    #   system_prompt: "You are a helpful assistant. Current time is {current_time}."
    #   # ... other prompts ...

    # Default values, can be overridden by environment variables.
    timezone: "UTC"
    max_history_messages: 3
    history_max_age_hours: 2
    delegation_security_level: "confirm" # Default: "blocked", "confirm", or "unrestricted"

  tools_config:
    # `enable_local_tools` are not explicitly listed here for the default profile.
    # The application currently enables all available local tools.
    enable_local_tools:
      - "add_or_update_note"
      - "get_note"
      - "list_notes"
      - "delete_note"
      - "schedule_future_callback"
      - "schedule_recurring_task"
      - "schedule_reminder"
      - "schedule_action"
      - "schedule_recurring_action"
      - "list_pending_callbacks"
      - "modify_pending_callback"
      - "cancel_pending_callback"
      - "search_documents"
      - "get_full_document_content"
      - "get_message_history"
      - "get_user_documentation_content"
      - "ingest_document_from_url"
      - "execute_script"
      - "send_message_to_user"
      - "add_calendar_event"
      - "search_calendar_events"
      - "modify_calendar_event"
      - "delete_calendar_event"
      - "delegate_to_service"
      - "query_recent_events" # Event system tool
      - "create_event_listener" # Event system tool
      - "render_home_assistant_template" # Home Assistant template rendering
      - "list_event_listeners" # Event system tool
      - "delete_event_listener" # Event system tool
      - "toggle_event_listener" # Event system tool
      - "test_event_listener" # Event system tool
    enable_mcp_server_ids: # Explicitly define MCP servers for the default profile
      - "time"
      - "brave"
      - "python"
      - "homeassistant"
      - "google-maps"
      # The "browser" mcp server is intentionally excluded here.

    # Tools requiring explicit user confirmation before execution for this default profile.
    # This list is overridden by the TOOLS_REQUIRING_CONFIRMATION environment variable if set.
    confirm_tools:
      - delete_calendar_event
      - modify_calendar_event
      # - tool_that_posts_online
    mcp_initialization_timeout_seconds: 60 # Default 1 minute
  
  # Default list of slash commands that trigger this profile.
  # Can be overridden by individual service_profiles.
  slash_commands: []

# --- Service Profiles ---
# Defines specific assistant profiles with potentially different configurations.
service_profiles:
  - id: "default_assistant"
    description: "Main assistant using default settings, without browser tools. Suitable for general tasks, note-taking, calendar management, and information retrieval from stored documents."
    # This profile implicitly uses all settings from 'default_profile_settings'
    # as no specific 'processing_config' or 'tools_config' is defined here,
    # thus inheriting the tools_config that excludes the browser.

  - id: "browser_profile"
    description: "Assistant profile with web browsing capabilities for complex browser interactions like filling forms or navigating JavaScript-heavy sites. For simple web page scraping to extract content, consider using the `ingest_document_from_url` tool or direct MCP browser tools if available."
    processing_config:
      # Optionally, use a different LLM model optimized for browsing or summarization
      # llm_model: "claude-3-sonnet-20240229"
      prompts: # MERGES with default_profile_settings.processing_config.prompts
        system_prompt: "You are an assistant with web browsing capabilities interacting with {user_name}. After any tool calls you make, your final text response will be sent directly to {user_name}. Do NOT use the 'send_message_to_user' tool to respond to {user_name} - that tool is only for sending messages to OTHER users. Current time is {current_time}."
      delegation_security_level: "unrestricted" # This profile can be delegated to without forced confirmation
    tools_config: # REPLACES default_profile_settings.tools_config entirely for this profile
      # enable_local_tools: [] # Example: if you want NO local tools for this profile
      enable_mcp_server_ids:
        - "browser" # Only enable the browser MCP server
      confirm_tools: # Define tools requiring confirmation specifically for this profile
        - "browse_url" # Assuming 'browse_url' is a tool from the browser MCP server
    slash_commands:
      - "/browse"

  - id: "research"
    description: "Assistant profile for deep research, utilizing the Perplexity Sonar model. Ideal for comprehensive information gathering and analysis when web browsing or specific tool execution is not required."
    processing_config:
      llm_model: "openrouter/perplexity/sonar-deep-research"
      prompts:
        system_prompt: "You are a research assistant interacting with {user_name}. Please focus on providing comprehensive and accurate information. After any tool calls you make, your final text response will be sent directly to {user_name}. Do NOT use the 'send_message_to_user' tool to respond to {user_name} - that tool is only for sending messages to OTHER users."
      # Inherits default timezone, history settings.
      # No specific context providers are added by default for this profile.
      delegation_security_level: "unrestricted"
    tools_config: # REPLACES default_profile_settings.tools_config entirely for this profile
      enable_local_tools: [] # No local tools for this profile
      enable_mcp_server_ids: [] # No MCP tools for this profile
      confirm_tools: [] # No tools to confirm
    slash_commands:
      - "/research"

  - id: "event_handler"
    description: "Restricted assistant profile for automated script-event integration. Uses fast Haiku model with read-only and non-destructive tools only."
    processing_config:
      llm_model: "claude-3-5-haiku-20241022"
      prompts:
        system_prompt: "You are an automated event handler assistant. You are responding to events from scripts and automations. Provide clear, concise responses focused on the event context. Current time is {current_time}."
      max_history_messages: 1  # Minimal history for event processing
      history_max_age_hours: 0.5  # 30 minutes - events are typically immediate
      delegation_security_level: "blocked"  # Cannot delegate to other services
    tools_config: # REPLACES default_profile_settings.tools_config entirely for this profile
      enable_local_tools:
        # Core data tools (read/write for notes, read-only for documents)
        - "add_or_update_note"
        - "list_notes"
        - "get_note"
        - "search_documents"
        # Communication (Telegram only to prevent email spam)
        - "send_message_to_user"
        # Calendar read-only
        - "search_calendar_events"
        # Event system query only (no listener creation/modification)
        - "query_recent_events"
      enable_mcp_server_ids:
        # Home Assistant read-only access
        - "homeassistant"  # Configured to only allow get_entity_state and get_all_entities
      confirm_tools: []  # No confirmation needed for automated operations
    slash_commands: []  # Not accessible via slash commands

# Other global settings like llm_parameters, indexing_pipeline_config remain at top level.
# Secrets (telegram_token, api_keys, database_url) are primarily from env.
# Model, embedding_model, server_url, storage_paths are also top-level or env.
