event_system:
  enabled: true
  storage:
    sample_interval_hours: 1.0
    max_event_size: 100000
    retention_hours: 48
  sources:
    home_assistant:
      enabled: true
llm_parameters:
  openrouter/google/gemini-:
    reasoning:
      effort: medium
indexing_pipeline_config:
  processors:
    - type: TitleExtractor
    - type: PDFTextExtractor
    - type: WebFetcher
      config: {}
    - type: LLMSummaryGenerator
      config:
        input_content_types:
          - original_document_file
          - raw_body_text
          - extracted_markdown_content
          - fetched_content_markdown
        target_embedding_type: llm_generated_summary
    - type: TextChunker
      config:
        chunk_size: 1000
        chunk_overlap: 100
        embedding_type_prefix_map:
          raw_body_text: content_chunk
          raw_file_text: content_chunk
          raw_note_text: content_chunk
          extracted_markdown_content: content_chunk
          fetched_content_markdown: content_chunk
    - type: EmbeddingDispatch
      config:
        embedding_types_to_dispatch:
          - title
          - content_chunk
          - llm_generated_summary
          - raw_note_text
          - raw_body_text
          - raw_file_text
          - extracted_markdown_content
          - fetched_content_markdown
default_profile_settings:
  processing_config:
    home_assistant_context_template: "{# Macro to format a distance value (assumed to be in km by the distance() function) \n   into a user-friendly string with 'm' or 'km'. #}\n{%- macro get_formatted_distance_string(distance_value_km) -%}\n  {%- if distance_value_km is number and distance_value_km < 1 -%}\n    {{- (distance_value_km * 1000) | round(0) ~ \" m\" -}}\n  {%- elif distance_value_km is number -%}\n    {{- distance_value_km | round(1) ~ \" km\" -}}\n  {%- else -%}\n    {{- \"\" -}} {# Handle cases where distance might not be a number #}\n  {%- endif -%}\n{%- endmacro -%}\n\n{# Macro to find the closest zone to a person and its distance.\n   It populates the 'out_ns.result_dict' with a dictionary \n   containing {'zone_obj': <state_obj>, 'distance': <float>}, or sets it to none. #}\n{%- macro find_closest_zone_data(person_obj, out_ns) -%}\n  {%- set zones_with_distances = namespace(list=[]) -%}\n\n  {%- for zone_obj in states.zone | rejectattr('entity_id', 'equalto', 'zone.near_home') -%}\n    {%- set current_dist = distance(zone_obj.entity_id, person_obj.entity_id) -%}\n    {%- if current_dist is number -%}\n      {%- set zones_with_distances.list = zones_with_distances.list + [{'zone_obj': zone_obj, 'distance': current_dist}] -%}\n    {%- endif -%}\n  {%- endfor -%}\n\n  {%- if zones_with_distances.list -%}\n    {%- set out_ns.result_dict = (zones_with_distances.list | sort(attribute='distance') | first) -%}\n  {%- else -%}\n    {%- set out_ns.result_dict = none -%}\n  {%- endif -%}\n  {# This macro modifies 'out_ns' by side effect and does not render its primary data as output. #}\n{%- endmacro -%}\n\n{# Macro to determine and return the detailed portion of a 'not_home' status message.\n   For example: \" 1.2 km from Work\" or \" (location data unavailable)\". #}\n{%- macro get_not_home_status_details(person_obj) -%}\n  {%- if state_attr(person_obj.entity_id, 'latitude') is not none and state_attr(person_obj.entity_id, 'longitude') is not none -%}\n    {%- if states.zone | length > 0 -%}\n      {# Create a namespace to hold the output from the find_closest_zone_data macro #}\n      {%- set closest_zone_ns = namespace(result_dict=none) -%}\n      {# Call the macro; it will populate closest_zone_ns.result_dict by side effect. #}\n      {# Assigning to '_' signifies we're primarily interested in the side effect, not the macro's direct string output (which should be empty). #}\n      {%- set _ = find_closest_zone_data(person_obj, closest_zone_ns) -%} \n      \n      {%- set closest_zone_data = closest_zone_ns.result_dict -%} {# Retrieve the actual dictionary #}\n\n      {%- if closest_zone_data is not none and closest_zone_data.distance is number -%}\n        {{- \" \" ~ get_formatted_distance_string(closest_zone_data.distance) ~ \" from \" ~ closest_zone_data.zone_obj.name -}}\n      {%- elif closest_zone_data is not none -%} {# A zone was found, but distance was invalid for formatting #}\n        {{- \" (could not calculate distance to \" ~ closest_zone_data.zone_obj.name ~ \")\" -}}\n      {%- else -%}\n        {{- \" (unable to find a suitable closest zone)\" -}}\n      {%- endif -%}\n    {%- else -%}\n      {{- \" (no zones defined)\" -}}\n    {%- endif -%}\n  {%- else -%}\n    {{- \" (location data unavailable)\" -}}\n  {%- endif -%}\n{%- endmacro -%}\n\n{# Macro to format a timestamp in a friendly way #}\n{%- macro friendly_time(timestamp) -%}\n  {%- set dt = timestamp | as_datetime | as_local -%}\n  {%- set today = now().date() -%}\n  {%- set tomorrow = (now() + timedelta(days=1)).date() -%}\n  {%- set dt_date = dt.date() -%}\n  \n  {%- if dt_date == today -%}\n    {{- \"today at \" ~ (dt | as_timestamp | timestamp_custom('%-I:%M %p')) | lower -}}\n  {%- elif dt_date == tomorrow -%}\n    {{- \"tomorrow at \" ~ (dt | as_timestamp | timestamp_custom('%-I:%M %p')) | lower -}}\n  {%- elif (dt_date - today).days <= 6 and dt_date > today -%}\n    {{- (dt | as_timestamp | timestamp_custom('%A at %-I:%M %p')) | lower -}}\n  {%- else -%}\n    {{- dt | as_timestamp | timestamp_custom('%b %-d at %-I:%M %p') -}}\n  {%- endif -%}\n{%- endmacro -%}\n\n{%- for person in states.person -%}\n  {%- if not loop.first -%}{{ \"\\n\" }}{%- endif -%} {# Ensures each person's status starts on a new line. #}\n  \n  {{- person.name -}}\n  {%- if person.state == 'not_home' -%}\n    {{- \" is not home\" ~ get_not_home_status_details(person) -}}\n  {%- else -%}\n    {# If not 'not_home', the person.state is the friendly name of the zone they are in. #}\n    {{- \" is at \" ~ person.state -}}\n  {%- endif -%}\n  {%- set lat = state_attr(person.entity_id, 'latitude') -%}\n  {%- set lon = state_attr(person.entity_id, 'longitude') -%}\n  {%- if lat is not none and lon is not none -%}\n    {{- \" (\" ~ lat ~ \", \" ~ lon ~ \")\" -}}\n  {%- endif -%}\n{%- endfor -%}\n\n{# Process electricity price forecasts #}\n{%- set forecasts = state_attr(\"sensor.electricity_price_forecast\", \"forecasts\") or [] -%}\n{%- set significant_periods = [] -%}\n{%- set current = namespace(type=none, start=none, end=none, min=none, max=none) -%}\n\n{%- for forecast in forecasts | sort(attribute='start_time') -%}\n  {# Determine if this forecast is significant #}\n  {%- set price_type = none -%}\n  {%- if forecast.per_kwh < 0.15 -%}\n    {%- set price_type = \"very low\" -%} {%- elif forecast.per_kwh < 0.25 -%} {%- set price_type = \"low\" -%}\n  {%- elif forecast.descriptor in [\"high\", \"spike\"] -%}\n    {%- set price_type = \"very high\" -%}\n  {%- endif -%}\n  \n  {%- if price_type -%}\n    {# This is a significant price period #}\n    {%- if not current.type -%}\n      {# Start new period #}\n      {%- set current.type = price_type -%}\n      {%- set current.start = forecast.start_time -%}\n      {%- set current.end = forecast.end_time -%}\n      {%- set current.min = forecast.per_kwh -%}\n      {%- set current.max = forecast.per_kwh -%}\n    {%- elif current.type == price_type and current.end == forecast.start_time -%}\n      {# Extend current period (adjacent and same type) #}\n      {%- set current.end = forecast.end_time -%}\n      {%- set current.min = [current.min, forecast.per_kwh] | min -%}\n      {%- set current.max = [current.max, forecast.per_kwh] | max -%}\n    {%- else -%}\n      {# Save current period and start new one - using safe list concatenation #}\n      {%- set significant_periods = significant_periods + [{\n          \"type\": current.type,\n          \"start\": current.start,\n          \"end\": current.end,\n          \"min\": current.min,\n          \"max\": current.max\n        }] -%}\n      {%- set current.type = price_type -%}\n      {%- set current.start = forecast.start_time -%}\n      {%- set current.end = forecast.end_time -%}\n      {%- set current.min = forecast.per_kwh -%}\n      {%- set current.max = forecast.per_kwh -%}\n    {%- endif -%}\n  {%- elif current.type -%}\n    {# Save current period and reset - using safe list concatenation #}\n    {%- set significant_periods = significant_periods + [{\n        \"type\": current.type,\n        \"start\": current.start,\n        \"end\": current.end,\n        \"min\": current.min,\n        \"max\": current.max\n      }] -%}\n    {%- set current.type = none -%}\n    {%- set current.start = none -%}\n    {%- set current.end = none -%}\n    {%- set current.min = none -%}\n    {%- set current.max = none -%}\n  {%- endif -%}\n{%- endfor -%}\n\n{# Save any remaining period - using safe list concatenation #}\n{%- if current.type -%}\n  {%- set significant_periods = significant_periods + [{\n      \"type\": current.type,\n      \"start\": current.start,\n      \"end\": current.end,\n      \"min\": current.min,\n      \"max\": current.max\n    }] -%}\n{%- endif -%}\n{{ \"\\n\\n\" }}\n## Energy price\nCurrently: {{ states(\"sensor.general_price\") }} ({{ state_attr(\"sensor.general_price\", \"descriptor\") }})\n\n{%- if significant_periods -%}\n  {%- for period in significant_periods %}\nPrice is {{ period.type }} ({{ period.min | round(2) }} to {{ period.max | round(2) }} c/kWh) from {{ friendly_time(period.start) }} to {{ friendly_time(period.end) }}\n  {%- endfor -%}\n{%- else -%}\nNo significant energy price periods are forecast.\n{%- endif -%}\n"
    timezone: UTC
    max_history_messages: 3
    history_max_age_hours: 2
    delegation_security_level: confirm
  tools_config:
    enable_local_tools:
      - add_or_update_note
      - get_note
      - list_notes
      - delete_note
      - schedule_future_callback
      - schedule_recurring_task
      - schedule_reminder
      - schedule_action
      - schedule_recurring_action
      - list_pending_callbacks
      - modify_pending_callback
      - cancel_pending_callback
      - search_documents
      - get_full_document_content
      - get_message_history
      - get_user_documentation_content
      - ingest_document_from_url
      - execute_script
      - send_message_to_user
      - add_calendar_event
      - search_calendar_events
      - modify_calendar_event
      - delete_calendar_event
      - delegate_to_service
      - query_recent_events
      - create_event_listener
      - render_home_assistant_template
      - list_event_listeners
      - delete_event_listener
      - toggle_event_listener
      - test_event_listener
    enable_mcp_server_ids:
      - time
      - brave
      - python
      - homeassistant
      - google-maps
    confirm_tools:
      - delete_calendar_event
      - modify_calendar_event
      - add_or_update_note
      # - tool_that_posts_online
    mcp_initialization_timeout_seconds: 60 # Default 1 minute
  # Default list of slash commands that trigger this profile.
  # Can be overridden by individual service_profiles.
  slash_commands: []
service_profiles:
  - id: default_assistant
    description: Main assistant using default settings, without browser tools. Suitable for general tasks, note-taking, calendar management, and information retrieval from stored documents.
    processing_config:
      retry_config:
        primary:
          provider: google
          model: gemini-2.5-pro
        fallback:
          provider: openai
          model: o4-mini
  - id: browser_profile
    description: Assistant profile with web browsing capabilities for complex browser interactions like filling forms or navigating JavaScript-heavy sites. For simple web scraping, consider using the ingest_document_from_url tool or direct MCP browser tools.
    processing_config:
      provider: google
      llm_model: gemini-2.5-pro
      prompts:
        system_prompt: You are an assistant with web browsing capabilities interacting with {user_name}. After any tool calls you make, your final text response will be sent directly to {user_name}. Do NOT use the 'send_message_to_user' tool to respond to {user_name} - that tool is only for sending messages to OTHER users. Current time is {current_time}.
      delegation_security_level: unrestricted
    tools_config:
      enable_mcp_server_ids:
        - browser
      confirm_tools:
        - browse_url
    slash_commands:
      - /browse
  - id: research
    description: Assistant profile for deep research, utilizing the Perplexity Sonar model. Ideal for comprehensive information gathering and analysis when web browsing or specific tool execution is not required.
    processing_config:
      provider: litellm
      llm_model: openrouter/perplexity/sonar-deep-research
      prompts:
        system_prompt: You are a research assistant interacting with {user_name}. Please focus on providing comprehensive and accurate information. After any tool calls you make, your final text response will be sent directly to {user_name}. Do NOT use the 'send_message_to_user' tool to respond to {user_name} - that tool is only for sending messages to OTHER users.
      delegation_security_level: unrestricted
    tools_config:
      enable_local_tools: []
      enable_mcp_server_ids: []
      confirm_tools: []
    slash_commands:
      - /research
  - id: event_handler
    description: Restricted assistant profile for automated script-event integration. Uses Gemini 2.5 Pro with read-only and non-destructive tools only.
    processing_config:
      provider: google
      llm_model: gemini-2.5-pro
      prompts:
        system_prompt: You are an automated event handler assistant. You are responding to events from scripts and automations. Provide clear, concise responses focused on the event context. Current time is {current_time}.
      max_history_messages: 1
      history_max_age_hours: 0.5
      delegation_security_level: blocked
    tools_config:
      enable_local_tools:
        - add_or_update_note
        - list_notes
        - get_note
        - search_documents
        - send_message_to_user
        - search_calendar_events
        - query_recent_events
      enable_mcp_server_ids:
        - homeassistant
      confirm_tools: []
    slash_commands: []

