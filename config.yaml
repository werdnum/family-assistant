# Configuration for Family Assistant
# LLM Provider Configuration
# Each service profile can specify a 'provider' in its processing_config.
# Available providers: 'litellm' (default), 'openai', 'google'
# - 'litellm': Uses LiteLLM for all models (supports many providers)
# - 'openai': Uses direct OpenAI SDK (requires OPENAI_API_KEY)
# - 'google': Uses direct Google GenAI SDK (requires GEMINI_API_KEY)
#
# Retry and Fallback Configuration (NEW):
# Use 'retry_config' format for automatic retry and fallback:
# processing_config:
#   retry_config:
#     primary:
#       provider: "openai"
#       model: "gpt-4o"
#     fallback:
#       provider: "google"
#       model: "gemini-2.5-pro"
# The system will retry once on the primary model for transient errors,
# then fall back to the fallback model if needed.
# Event system configuration
event_system:
  enabled: true
  storage:
    sample_interval_hours: 1.0 # Store 1 event per entity per hour
    max_event_size: 100000 # 100KB max event size
    retention_hours: 48
  sources:
    home_assistant:
      enabled: true
      # URL and token are shared with context provider
# LLM provider-specific parameters
# Keys can be full model names or prefixes (ending with '-')
# Parameters defined here will be passed as keyword arguments to litellm.completion
# for matching models.
llm_parameters:
  # Example for Gemini models via OpenRouter
  "openrouter/google/gemini-":
    reasoning: # Nest OpenRouter-specific reasoning params here
      effort: medium
      # Other top-level parameters for this model could still go here
      # temperature: 0.8
  # Example for another model type
  # "anthropic/claude-3-":
  #   temperature: 0.75
  #   top_k: 50
# Configuration for the document indexing pipeline
indexing_pipeline_config:
  # Optional global configurations for the pipeline itself, if IndexingPipeline supports them
  # global_pipeline_config:
  #   some_global_setting: value
  processors:
    - type: "TitleExtractor"
      # config: {} # No specific config for TitleExtractor in this example
    - type: "PDFTextExtractor"
      # config: {} # No specific config for PDFTextExtractor
    - type: "WebFetcher"
      config: {} # No specific config other than scraper injection for now
    - type: "LLMSummaryGenerator" # Specific config for WebFetcherProcessor
      config:
        # llm_client is injected by DocumentIndexer
        input_content_types:
          - "original_document_file"
          - "raw_body_text" # For emails, if used by this indexer
          - "extracted_markdown_content" # From PDFTextExtractor
          - "fetched_content_markdown" # From WebFetcherProcessor
        target_embedding_type: "llm_generated_summary"
        # max_content_length: 100000 # Example, if needed
    - type: "TextChunker"
      config:
        chunk_size: 1000
        chunk_overlap: 100
        embedding_type_prefix_map:
          # For content parts directly provided to DocumentIndexer
          raw_body_text: "content_chunk"
          raw_file_text: "content_chunk"
          raw_note_text: "content_chunk" # From NotesIndexer
          # For content generated by other processors
          extracted_markdown_content: "content_chunk" # From PDFTextExtractor
          fetched_content_markdown: "content_chunk" # From WebFetcherProcessor
    - type: "EmbeddingDispatch"
      config:
        embedding_types_to_dispatch:
          - "title"
          # - "summary" # If you have a manual summary type
          - "content_chunk"
          - "llm_generated_summary" # From LLMSummaryGeneratorProcessor
          # Raw content types - will be embedded if small enough, stored if too large
          - "raw_note_text"
          - "raw_body_text"
          - "raw_file_text"
          - "extracted_markdown_content" # Full PDF text
          - "fetched_content_markdown" # Full web page content
# Other future configurations can go here
# e.g., web_server_port: 8080

# --- Calendar Configuration ---
# Calendar configuration is shared across all profiles.
# Populated from environment variables (CALDAV_*, ICAL_URLS).
# calendar_config:
#   caldav:
#     username: "user"
#     password: "password"
#     calendar_urls: ["url1"]
#   ical:
#     urls: ["url2"]

# --- Default Service Profile Configuration ---
# Settings for the primary, default assistant behavior.
default_profile_settings:
  processing_config:
    home_assistant_context_template: "{# Macro to format a distance value (assumed to be in km by the distance() function) \n   into a user-friendly string with 'm' or 'km'. #}\n{%- macro get_formatted_distance_string(distance_value_km) -%}\n  {%- if distance_value_km is number and distance_value_km < 1 -%}\n    {{- (distance_value_km * 1000) | round(0) ~ \" m\" -}}\n  {%- elif distance_value_km is number -%}\n    {{- distance_value_km | round(1) ~ \" km\" -}}\n  {%- else -%}\n    {{- \"\" -}} {# Handle cases where distance might not be a number #}\n  {%- endif -%}\n{%- endmacro -%}\n\n{# Macro to find the closest zone to a person and its distance.\n   It populates the 'out_ns.result_dict' with a dictionary \n   containing {'zone_obj': <state_obj>, 'distance': <float>}, or sets it to none. #}\n{%- macro find_closest_zone_data(person_obj, out_ns) -%}\n  {%- set zones_with_distances = namespace(list=[]) -%}\n\n  {%- for zone_obj in states.zone | rejectattr('entity_id', 'equalto', 'zone.near_home') -%}\n    {%- set current_dist = distance(zone_obj.entity_id, person_obj.entity_id) -%}\n    {%- if current_dist is number -%}\n      {%- set zones_with_distances.list = zones_with_distances.list + [{'zone_obj': zone_obj, 'distance': current_dist}] -%}\n    {%- endif -%}\n  {%- endfor -%}\n\n  {%- if zones_with_distances.list -%}\n    {%- set out_ns.result_dict = (zones_with_distances.list | sort(attribute='distance') | first) -%}\n  {%- else -%}\n    {%- set out_ns.result_dict = none -%}\n  {%- endif -%}\n  {# This macro modifies 'out_ns' by side effect and does not render its primary data as output. #}\n{%- endmacro -%}\n\n{# Macro to determine and return the detailed portion of a 'not_home' status message.\n   For example: \" 1.2 km from Work\" or \" (location data unavailable)\". #}\n{%- macro get_not_home_status_details(person_obj) -%}\n  {%- if state_attr(person_obj.entity_id, 'latitude') is not none and state_attr(person_obj.entity_id, 'longitude') is not none -%}\n    {%- if states.zone | length > 0 -%}\n      {# Create a namespace to hold the output from the find_closest_zone_data macro #}\n      {%- set closest_zone_ns = namespace(result_dict=none) -%}\n      {# Call the macro; it will populate closest_zone_ns.result_dict by side effect. #}\n      {# Assigning to '_' signifies we're primarily interested in the side effect, not the macro's direct string output (which should be empty). #}\n      {%- set _ = find_closest_zone_data(person_obj, closest_zone_ns) -%} \n      \n      {%- set closest_zone_data = closest_zone_ns.result_dict -%} {# Retrieve the actual dictionary #}\n\n      {%- if closest_zone_data is not none and closest_zone_data.distance is number -%}\n        {{- \" \" ~ get_formatted_distance_string(closest_zone_data.distance) ~ \" from \" ~ closest_zone_data.zone_obj.name -}}\n      {%- elif closest_zone_data is not none -%} {# A zone was found, but distance was invalid for formatting #}\n        {{- \" (could not calculate distance to \" ~ closest_zone_data.zone_obj.name ~ \")\" -}}\n      {%- else -%}\n        {{- \" (unable to find a suitable closest zone)\" -}}\n      {%- endif -%}\n    {%- else -%}\n      {{- \" (no zones defined)\" -}}\n    {%- endif -%}\n  {%- else -%}\n    {{- \" (location data unavailable)\" -}}\n  {%- endif -%}\n{%- endmacro -%}\n\n{%- for person in states.person -%}\n  {%- if not loop.first -%}{{ \"\\n\" }}{%- endif -%} {# Ensures each person's status starts on a new line. #}\n  \n  {{- person.name -}}\n  {%- if person.state == 'not_home' -%}\n    {{- \" is not home\" ~ get_not_home_status_details(person) -}}\n  {%- else -%}\n    {# If not 'not_home', the person.state is the friendly name of the zone they are in. #}\n    {{- \" is at \" ~ person.state -}}\n  {%- endif -%}\n  {%- set lat = state_attr(person.entity_id, 'latitude') -%}\n  {%- set lon = state_attr(person.entity_id, 'longitude') -%}\n  {%- if lat is not none and lon is not none -%}\n    {{- \" (\" ~ lat ~ \", \" ~ lon ~ \")\" -}}\n  {%- endif -%}\n{%- endfor -%}\n\n{% set forecasts = state_attr(\"sensor.electricity_price_forecast\", \"forecasts\") or [] -%}\n{%- set significant_periods = [] -%}\n{# Use a namespace to allow modifying variables inside the loop #}\n{%- set current_period = namespace(start_time=none, end_time=none, type=none, raw_end_time_for_comparison=none) -%}\n\n{# Ensure forecasts are sorted by start_time, as processing relies on this order #}\n{%- for forecast in forecasts | sort(attribute='start_time') -%}\n  {%- set descriptor = forecast.descriptor -%}\n  {%- set f_start_time_str = forecast.start_time -%}\n  {%- set f_end_time_str = forecast.end_time -%}\n\n  {%- set forecast_type = namespace(value=none) -%}\n  {%- if descriptor in [\"extremely_low\", \"very_low\"] -%}\n    {%- set forecast_type.value = \"very low\" -%}\n  {%- elif descriptor in [\"high\", \"spike\"] -%}\n    {%- set forecast_type.value = \"very high\" -%}\n  {%- endif -%}\n\n  {%- if forecast_type.value -%}\n    {#- This forecast is of interest (very low or very high price) -#}\n    {%- if current_period.type == none -%}\n      {#- No active significant period, so start a new one -#}\n      {%- set current_period.start_time = f_start_time_str -%}\n      {%- set current_period.raw_end_time_for_comparison = f_end_time_str -%}\n      {%- set current_period.end_time = f_end_time_str -%}\n      {%- set current_period.type = forecast_type.value -%}\n      {%- set current_period.min = forecast.per_kwh -%}\n      {%- set current_period.max = forecast.per_kwh -%}\n    {%- elif current_period.type == forecast_type.value -%}\n      {#- Current forecast is of the same significant type as the active period. Check for adjacency. -#}\n      {#- Adjacency condition: current forecast's start_time should be very close to the active period's end_time. -#}\n      {#- We use as_timestamp for robust comparison, allowing for small gaps (e.g., 1 second). -#}\n      {%- set prev_end_ts = as_timestamp(current_period.raw_end_time_for_comparison) | default(0) -%}\n      {%- set curr_start_ts = as_timestamp(f_start_time_str) | default(0) -%}\n\n      {#- Consider adjacent if start is within ~5 seconds of previous end, and not before it. -#}\n      {#- This threshold (5 seconds) can be adjusted based on data patterns. -#}\n      {%- if curr_start_ts - prev_end_ts <= 5 and curr_start_ts >= prev_end_ts -%}\n        {#- Adjacent and same type: extend the current period -#}\n        {%- set current_period.raw_end_time_for_comparison = f_end_time_str -%}\n        {%- set current_period.end_time = f_end_time_str -%}\n        {%- set current_period.min = [current_period.min, forecast.per_kwh]|min -%}\n        {%- set current_period.max = [current_period.max, forecast.per_kwh]|max -%}\n      {%- else -%}\n        {#- Not adjacent: finalize the old period and start a new one -#}\n        {%- set significant_periods = significant_periods + [{\n            \"type\": current_period.type,\n            \"start\": current_period.start_time,\n            \"end\": current_period.end_time\n          }] -%}\n        {%- set current_period.start_time = f_start_time_str -%}\n        {%- set current_period.raw_end_time_for_comparison = f_end_time_str -%}\n        {%- set current_period.end_time = f_end_time_str -%}\n        {%- set current_period.type = forecast_type.value -%}\n        {%- set current_period.min = forecast.per_kwh -%}\n        {%- set current_period.max = forecast.per_kwh -%}\n      {%- endif -%}\n    {%- else -%} \n      {# Different significant type (e.g., was \"very high\", now \"very low\"): finalize old, start new #}\n      {%- set significant_periods = significant_periods + [{\n          \"type\": current_period.type,\n          \"start\": current_period.start_time,\n          \"end\": current_period.end_time\n        }] -%}\n      {%- set current_period.start_time = f_start_time_str -%}\n      {%- set current_period.raw_end_time_for_comparison = f_end_time_str -%}\n      {%- set current_period.end_time = f_end_time_str -%}\n      {%- set current_period.type = forecast_type.value -%}\n      {%- set current_period.min = forecast.per_kwh -%}\n      {%- set current_period.max = forecast.per_kwh -%}\n    {%- endif -%}\n  {%- else -%}\n    {#- Forecast is not of interest (e.g., neutral, low) -#}\n    {%- if current_period.type != none -%}\n      {#- A significant period was active, finalize it -#}\n      {%- set significant_periods = significant_periods + [{\n          \"type\": current_period.type,\n          \"start\": current_period.start_time,\n          \"end\": current_period.end_time,\n          \"min\": current_period.min,\n          \"max\": current_period.max,\n        }] -%}\n      {%- set current_period.start_time = none -%}\n      {%- set current_period.raw_end_time_for_comparison = none -%}\n      {%- set current_period.end_time = none -%}\n      {%- set current_period.type = none -%}\n      {%- set current_period.min = none -%}\n      {%- set current_period.max = none -%}\n    {%- endif -%}\n  {%- endif -%}\n{%- endfor -%}\n\n{# After the loop, finalize any period that was still active #}\n{%- if current_period.type != none -%}\n  {%- set significant_periods = significant_periods + [{\n      \"type\": current_period.type,\n      \"start\": current_period.start_time,\n      \"end\": current_period.end_time\n    }] -%}\n{%- endif %}\n\n## Energy price\nCurrently: {{ states(\"sensor.general_price\") }} ({{ state_attr(\"sensor.general_price\", \"descriptor\") }})\n\n{% if significant_periods -%}\n  {%- for period in significant_periods %}\nPrice is {{ period.type }} ({{ period.min }} to {{ period.max }}) from {{ period.start | as_datetime | as_local }} to {{ period.end | as_datetime | as_local }}\n  {%- endfor -%}\n{%- else -%}\nNo very high or very low energy price periods are forecast.\n{%- endif -%}"
    # `prompts` are loaded from prompts.yaml. This key is a placeholder for that structure.
    # prompts:
    #   system_prompt: "You are a helpful assistant. Current time is {current_time}."
    #   # ... other prompts ...

    # Default values, can be overridden by environment variables.
    timezone: "UTC"
    max_history_messages: 3
    history_max_age_hours: 2
    # Web-specific history settings for better conversation context
    # web_max_history_messages: 100  # Uncomment to override default of 100
    # web_history_max_age_hours: 720  # Uncomment to override default of 720 (30 days)
    delegation_security_level: "confirm" # Default: "blocked", "confirm", or "unrestricted"
  tools_config:
    # `enable_local_tools` are not explicitly listed here for the default profile.
    # The application currently enables all available local tools.
    enable_local_tools:
      - "add_or_update_note"
      - "get_note"
      - "list_notes"
      - "delete_note"
      - "schedule_future_callback"
      - "schedule_recurring_task"
      - "schedule_reminder"
      - "schedule_action"
      - "schedule_recurring_action"
      - "list_pending_callbacks"
      - "modify_pending_callback"
      - "cancel_pending_callback"
      - "search_documents"
      - "get_full_document_content"
      - "get_message_history"
      - "get_user_documentation_content"
      - "ingest_document_from_url"
      - "execute_script"
      - "send_message_to_user"
      - "add_calendar_event"
      - "search_calendar_events"
      - "modify_calendar_event"
      - "delete_calendar_event"
      - "delegate_to_service"
      - "query_recent_events" # Event system tool
      - "create_event_listener" # Event system tool
      - "render_home_assistant_template" # Home Assistant template rendering
      - "list_event_listeners" # Event system tool
      - "delete_event_listener" # Event system tool
      - "toggle_event_listener" # Event system tool
      - "test_event_listener" # Event system tool
    enable_mcp_server_ids: # Explicitly define MCP servers for the default profile
      - "time"
      - "brave"
      - "python"
      - "homeassistant"
      - "google-maps"
      # The "browser" mcp server is intentionally excluded here.
    # Tools requiring explicit user confirmation before execution for this default profile.
    # This list is overridden by the TOOLS_REQUIRING_CONFIRMATION environment variable if set.
    confirm_tools:
      - delete_calendar_event
      - modify_calendar_event
      - add_or_update_note
      # - tool_that_posts_online
    mcp_initialization_timeout_seconds: 60 # Default 1 minute
  # Default list of slash commands that trigger this profile.
  # Can be overridden by individual service_profiles.
  slash_commands: []
# --- Service Profiles ---
# Defines specific assistant profiles with potentially different configurations.
# Provider Configuration:
# - 'google': Direct Google GenAI SDK integration (requires GEMINI_API_KEY)
# - 'openai': Direct OpenAI SDK integration (requires OPENAI_API_KEY)
# - 'litellm': LiteLLM for models not available via direct integration (default)
service_profiles:
  - id: "default_assistant"
    description: "Main assistant using default settings, without browser tools. Suitable for general tasks, note-taking, calendar management, and information retrieval from stored documents."
    # This profile implicitly uses all settings from 'default_profile_settings'
    # as no specific 'processing_config' or 'tools_config' is defined here,
    # thus inheriting the tools_config that excludes the browser.
    processing_config:
      # Using new retry_config format for reliability
      retry_config:
        primary:
          provider: "google"
          model: "gemini-2.5-pro"
        fallback:
          provider: "openai"
          model: "o4-mini"
  - id: "browser_profile"
    description: "Assistant profile with web browsing capabilities for complex browser interactions like filling forms or navigating JavaScript-heavy sites. For simple web scraping, consider using the ingest_document_from_url tool or direct MCP browser tools."
    processing_config:
      # Using simple format (no retry/fallback for browser tasks)
      provider: "google"
      llm_model: "gemini-2.5-pro"
      prompts: # MERGES with default_profile_settings.processing_config.prompts
        system_prompt: "You are an assistant with web browsing capabilities interacting with {user_name}. After any tool calls you make, your final text response will be sent directly to {user_name}. Do NOT use the 'send_message_to_user' tool to respond to {user_name} - that tool is only for sending messages to OTHER users. Current time is {current_time}."
      delegation_security_level: "unrestricted" # This profile can be delegated to without forced confirmation
    tools_config: # REPLACES default_profile_settings.tools_config entirely for this profile
      # enable_local_tools: [] # Example: if you want NO local tools for this profile
      enable_mcp_server_ids:
        - "browser" # Only enable the browser MCP server
      confirm_tools: # Define tools requiring confirmation specifically for this profile
        - "browse_url" # Assuming 'browse_url' is a tool from the browser MCP server
    slash_commands:
      - "/browse"
  - id: "research"
    description: "Assistant profile for deep research, utilizing the Perplexity Sonar model. Ideal for comprehensive information gathering and analysis when web browsing or specific tool execution is not required."
    processing_config:
      # Research profile still uses LiteLLM for access to Perplexity models
      provider: "litellm"
      llm_model: "openrouter/perplexity/sonar-deep-research"
      prompts:
        system_prompt: "You are a research assistant interacting with {user_name}. Please focus on providing comprehensive and accurate information. After any tool calls you make, your final text response will be sent directly to {user_name}. Do NOT use the 'send_message_to_user' tool to respond to {user_name} - that tool is only for sending messages to OTHER users."
      # Inherits default timezone, history settings.
      # No specific context providers are added by default for this profile.
      delegation_security_level: "unrestricted"
    tools_config: # REPLACES default_profile_settings.tools_config entirely for this profile
      enable_local_tools: [] # No local tools for this profile
      enable_mcp_server_ids: [] # No MCP tools for this profile
      confirm_tools: [] # No tools to confirm
    slash_commands:
      - "/research"
  - id: "event_handler"
    description: "Restricted assistant profile for automated script-event integration. Uses Gemini 2.5 Pro with read-only and non-destructive tools only."
    processing_config:
      # Using direct Google provider for consistency
      provider: "google"
      llm_model: "gemini-2.5-pro"
      prompts:
        system_prompt: "You are an automated event handler assistant. You are responding to events from scripts and automations. Provide clear, concise responses focused on the event context. Current time is {current_time}."
      max_history_messages: 1 # Minimal history for event processing
      history_max_age_hours: 0.5 # 30 minutes - events are typically immediate
      delegation_security_level: "blocked" # Cannot delegate to other services
    tools_config: # REPLACES default_profile_settings.tools_config entirely for this profile
      enable_local_tools:
        # Core data tools (read/write for notes, read-only for documents)
        - "add_or_update_note"
        - "list_notes"
        - "get_note"
        - "search_documents"
        # Communication (Telegram only to prevent email spam)
        - "send_message_to_user"
        # Calendar read-only
        - "search_calendar_events"
        # Event system query only (no listener creation/modification)
        - "query_recent_events"
      enable_mcp_server_ids:
        # Home Assistant read-only access
        - "homeassistant" # Configured to only allow get_entity_state and get_all_entities
      confirm_tools: [] # No confirmation needed for automated operations
    slash_commands: [] # Not accessible via slash commands

# Other global settings like llm_parameters, indexing_pipeline_config remain at top level.
# Secrets (telegram_token, api_keys, database_url) are primarily from env.
# Model, embedding_model, server_url, storage_paths are also top-level or env.
