# Refactoring Message History for Multi-Interface Support and Full Turn Context

This document outlines the plan to refactor the `message_history` storage and related components to:

1.  **Support Multiple Interfaces:** Allow interactions via different channels (Telegram, Web UI, Email, etc.) to be stored and distinguished within the same history table.
2.  **Capture Full Turn Context:** Persist the complete sequence of messages generated during a single agentic processing turn (including intermediate tool requests and responses), not just the final outcome. This provides better context for subsequent LLM calls and enables traceability.

## 1. Goal

The current `message_history` table uses `(chat_id, message_id)` as a primary key, which is specific to Telegram and prevents storing intermediate agent messages that don't have a direct Telegram counterpart. It also only stores the final assistant message of a turn, losing the context of tool interactions that led to that result.

This refactoring aims to create a more flexible and comprehensive message history by:

*   Using generic identifiers for interfaces and conversations.
*   Introducing a unique internal ID for each message record.
*   Adding a `turn_id` to group all messages generated within a single processing cycle.
*   Storing *all* messages generated by the agent during a turn (assistant requests, tool responses, final answer).

## 2. Schema Changes (`message_history` table)

The `message_history` table schema will be modified as follows (referencing `docs/SPECIFICATION.md#proposed-message_history-schema`):

*   **Add `internal_id`**: `BigInteger`, primary key, auto-incrementing. Serves as the unique identifier for each row.
*   **Add `interface_type`**: `String(50)`, non-nullable, indexed. Stores the identifier of the interface (e.g., 'telegram', 'web').
*   **Rename `chat_id` to `conversation_id`**: Change type to `String(255)`, non-nullable, indexed. Stores a generic conversation identifier (e.g., Telegram chat ID as string, Web Session UUID).
*   **Rename `message_id` to `interface_message_id`**: Change type to `String(255)`, **nullable**, indexed. Stores the message ID specific to the external interface (if one exists). Made nullable for agent-generated intermediate messages. Removed from the primary key.
*   **Add `turn_id`**: `String(36)`, **nullable**, indexed. Stores a UUID linking all agent-generated messages (assistant requests, tool responses, final answer) created within a single processing turn. The initial trigger message (e.g., user input) will have `turn_id = NULL`.
*   **Rename `tool_calls_info` to `tool_calls`**: Change column name for the JSONB field storing assistant tool *requests* for consistency with LLM APIs.

*   **Migration Required:** A database migration (e.g., using Alembic) is necessary to apply these schema changes to existing databases.

## 3. Storage Layer Changes (`src/family_assistant/storage/message_history.py`)

*   **`add_message_to_history`**:
    *   Update signature to accept `interface_type: str`, `conversation_id: str`, `interface_message_id: Optional[str]`, and `turn_id: Optional[str]`.
    *   Update `INSERT` statement to use the new/renamed columns.
*   **`get_message_by_id` -> `get_message_by_interface_id`**:
    *   Rename function for clarity.
    *   Update signature to accept `interface_type: str`, `conversation_id: str`, `interface_message_id: str`.
    *   Update `SELECT` statement to filter by these three columns.
*   **`get_recent_history`**:
    *   Update signature to accept `interface_type: str`, `conversation_id: str`.
    *   Update `SELECT` statement to filter by `interface_type` and `conversation_id`.
    *   Ensure it selects the renamed columns (`interface_message_id`, `tool_calls`).
*   **`get_grouped_message_history`**:
    *   Update `SELECT` statement for renamed columns.
    *   Update grouping logic to use `(interface_type, conversation_id)`.
*   **Add `get_messages_by_turn_id`**:
    *   Create a new function accepting `turn_id: str`.
    *   It should `SELECT` messages where `turn_id` matches, ordered by `internal_id` (or `timestamp`) to preserve sequence.

## 4. Processing Logic Changes (`src/family_assistant/processing.py`, `src/family_assistant/tools/types.py`)

*   **`ToolExecutionContext` (`tools/types.py`)**:
    *   Remove `chat_id`.
    *   Add `interface_type: str`.
    *   Add `conversation_id: str`.
*   **`ProcessingService.generate_llm_response_for_chat`**:
    *   Update signature: Replace `chat_id: int` with `interface_type: str, conversation_id: str`.
    *   Generate a unique `turn_id: str = str(uuid.uuid4())` at the start of the function.
    *   Pass `interface_type`, `conversation_id` to `storage.get_recent_history`.
    *   Pass the generated `turn_id`, `interface_type`, `conversation_id` to the `process_message` call.
    *   Implement logic to handle replies:
        *   Detect if the trigger message is a reply and get the `replied_to_interface_id`.
        *   Call `storage.get_message_by_interface_id` to find the replied-to message.
        *   If found and it has a `turn_id`, call `storage.get_messages_by_turn_id`.
        *   Format the resulting messages using `_format_history_for_llm`.
        *   Prepend this formatted context to the `messages` list sent to `process_message`, possibly with system message delimiters.
    *   Modify return signature to return `Tuple[List[Dict[str, Any]], Optional[Dict[str, Any]], Optional[str]]` (the list of messages generated during the turn, final reasoning info, error traceback).
*   **`ProcessingService.process_message`**:
    *   Update signature: Add `turn_id: str`, replace `chat_id: int` with `interface_type: str, conversation_id: str`.
    *   When creating agent-generated messages (`role='assistant'` or `role='tool'`) within the loop, add the `turn_id` to each message dictionary.
    *   Modify return signature to return `Tuple[List[Dict[str, Any]], Optional[Dict[str, Any]]]` (the list of *all* messages generated during this turn, final reasoning info).
*   **`ProcessingService._format_history_for_llm`**:
    *   Update logic to correctly handle the structure of assistant messages with `tool_calls` retrieved from the database (using the renamed `tool_calls` column).
    *   Ensure it correctly formats `role='tool'` messages based on the `tool_call_id` retrieved from the DB.

## 5. Interface Layer Changes (`src/family_assistant/telegram_bot.py`, etc.)

*   **`TelegramUpdateHandler.process_chat_queue` (and equivalents for other interfaces)**:
    *   Identify the `interface_type` (e.g., 'telegram').
    *   Identify the `conversation_id` (e.g., `str(chat_id)` for Telegram).
    *   Call `processing_service.generate_llm_response_for_chat` with `interface_type`, `conversation_id`. Receive the list of `turn_messages` generated during processing.
    *   **Saving Logic:**
        *   Save the initial **user message**: Use `interface_type`, `conversation_id`, its actual `interface_message_id` (e.g., `str(telegram_message_id)`), and `turn_id=None`.
        *   Iterate through the `turn_messages` list received from the processing service.
        *   For each message in `turn_messages`: Save it using `add_message_to_history`, passing `interface_type`, `conversation_id`, `interface_message_id=None`, and the `turn_id` present in the message dictionary. Include role, content, `tool_calls`, `tool_call_id`, `reasoning_info` as appropriate from the dictionary.
        *   If a final assistant message was successfully sent to the interface (e.g., `sent_assistant_message` in Telegram):
            *   Identify the corresponding message record in the database (e.g., the last 'assistant' message with the correct `turn_id`).
            *   Update that specific record to set its `interface_message_id` to the actual ID from the interface (e.g., `str(sent_assistant_message.message_id)`).

## 6. Tooling Changes (`src/family_assistant/tools/*`)

*   Review all local tool implementations (e.g., `schedule_future_callback_tool`, `add_or_update_note_tool`).
*   Any tool that previously accessed `exec_context.chat_id` must be updated to use `exec_context.interface_type` and `exec_context.conversation_id` instead, adapting its logic as needed.

## 7. Benefits

*   **Multi-Interface Ready:** The schema and logic cleanly separate interactions from different sources.
*   **Complete History:** Captures the full agent execution trace (tool requests, tool results, final response) for each turn.
*   **Improved Debugging/Traceability:** Allows analysing exactly how an assistant response was generated.
*   **Enhanced Context:** Provides the LLM with richer history, including tool interactions from previous turns, potentially improving response quality.
*   **Reply Context:** Enables fetching and providing the specific generation context when a user replies to a previous assistant message.

