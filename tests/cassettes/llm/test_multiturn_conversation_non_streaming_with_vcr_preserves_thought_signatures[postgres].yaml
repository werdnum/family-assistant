interactions:
  - request:
      body: '{"contents": [{"parts": [{"text": "System: You are a helpful assistant.\n\n[Processing iteration 1/5]"}], "role": "user"}, {"parts": [{"text": "use Python to calculate 1 + 1"}], "role": "user"}, {"parts": [{"text": "use Python to calculate 1 + 1"}], "role": "user"}], "tools": [{"functionDeclarations": [{"description": "Add a new note or update an existing note with the given title. Use this to remember information provided by the user. You can control whether the note appears in your system prompt with the include_in_prompt parameter.\n\nReturns: A string indicating the operation result. On success, returns ''Note [title] has been [created/updated] successfully.''. On error, returns ''Error: Failed to add/update note [title]. [error details]''.", "name": "add_or_update_note", "parameters": {"properties": {"title": {"description": "The unique title of the note.", "type": "STRING"}, "content": {"description": "The content of the note.", "type": "STRING"}, "include_in_prompt": {"description": "Whether to include this note in the system prompt context. Default is true. Set to false for notes that should be searchable but not always visible.", "type": "BOOLEAN"}, "append": {"description": "Whether to append the content to an existing note instead of replacing it. Default is false. When true, the content will be added to the end of the existing note with a newline separator.", "type": "BOOLEAN"}}, "required": ["title", "content"], "type": "OBJECT"}}, {"description": "Retrieve a specific note by its title to check its content and prompt inclusion status. Returns the note''s title, content, and whether it''s included in the system prompt.\n\nReturns: A JSON string containing a dict with the note information. If note exists, returns {''exists'': true, ''title'': [title], ''content'': [full content], ''include_in_prompt'': [boolean]}. If note not found, returns {''exists'': false, ''title'': [title], ''content'': null, ''include_in_prompt'': null}.", "name": "get_note", "parameters": {"properties": {"title": {"description": "The title of the note to retrieve.", "type": "STRING"}}, "required": ["title"], "type": "OBJECT"}}, {"description": "List all notes with their titles and prompt inclusion status. Can optionally filter to show only notes that are included or excluded from the system prompt.\n\nReturns: A JSON string containing a list of note summaries. Returns an array where each item is {''title'': [title], ''include_in_prompt'': [boolean], ''content_preview'': [first 100 chars of content]}. If no notes exist or match the filter, returns an empty array ''[]''.", "name": "list_notes", "parameters": {"properties": {"include_in_prompt": {"description": "Optional filter. If true, shows only notes included in prompt. If false, shows only excluded notes. If not specified, shows all notes.", "type": "BOOLEAN"}}, "required": [], "type": "OBJECT"}}, {"description": "Delete a note by its title. This permanently removes the note from the system. Use with caution as this action cannot be undone.\n\nReturns: A JSON string containing a dict with the operation result. On success, returns {''success'': true, ''message'': ''Note [title] deleted successfully.''}. If note not found, returns {''success'': false, ''message'': ''Note [title] not found.''}.", "name": "delete_note", "parameters": {"properties": {"title": {"description": "The title of the note to delete.", "type": "STRING"}}, "required": ["title"], "type": "OBJECT"}}, {"description": "Delegates a specific user request to another specialized assistant profile (service) that might have different tools or capabilities. Use this if the main assistant cannot handle a request directly or if a specialized profile is more appropriate for the task. The target profile''s ''delegation_security_level'' (blocked, confirm, unrestricted) can override the ''confirm_delegation'' parameter.\n\nAvailable service profiles:\n{available_service_profiles_with_descriptions}\n\nReturns: A string containing the delegated service''s response or an error message. On successful delegation, returns the text response from the target service. If service returns no text, returns ''Service [id] processed the request but provided no textual response.''. If service registry unavailable, returns ''Error: Service registry is not available to delegate the task.''. If target service not found, returns ''Error: Target service profile [id] not found.''. If delegation blocked by security policy, returns ''Error: Delegation to service profile [id] is not allowed.''. If confirmation required but unavailable, returns ''Error: Confirmation required to delegate to [id], but no confirmation mechanism is available.''. If user cancels confirmation, returns ''OK. Delegation to service [id] cancelled by user.''. If confirmation times out, returns ''Error: Confirmation timed out for delegating to [id].''. On delegation error, returns ''Error: Failed to delegate task to service [id]. Details: [error]'' or ''Error from [id] service: An error occurred during processing.''.", "name": "delegate_to_service", "parameters": {"properties": {"target_service_id": {"description": "The unique ID of the target service profile to delegate the request to (e.g., ''browser_profile'').", "type": "STRING"}, "user_request": {"description": "The specific request, question, or prompt to be processed by the target service.", "type": "STRING"}, "confirm_delegation": {"description": "Optional. If true, explicitly ask the user for confirmation before delegating the task. Defaults to false. This may be overridden if the target profile''s security level is ''confirm'' (always confirm) or ''blocked'' (never delegate). If the ''delegate_to_service'' tool itself is configured to require confirmation for the current profile, user confirmation will also be sought.", "type": "BOOLEAN"}, "attachment_ids": {"description": "Optional list of attachment UUIDs to include with the delegated request. These attachments must be accessible in the current conversation and will be passed to the target service for processing.", "items": {"description": "", "type": "STRING"}, "type": "ARRAY"}}, "required": ["target_service_id", "user_request"], "type": "OBJECT"}}, {"description": "Schedule a reminder to be sent at a specific time. Use this tool when users ask to be reminded of something. Supports automatic follow-up reminders if the user doesn''t respond.\n\nReturns: A string indicating the result. On success, returns ''OK. Reminder scheduled for [time].'' or ''OK. Reminder scheduled for [time] (with follow-ups every [interval], up to [N] times).'' if follow-up enabled. On parameter error, returns ''Error: Invalid reminder parameters. [details]''. On other errors, returns ''Error: Failed to schedule the reminder.''.", "name": "schedule_reminder", "parameters": {"properties": {"reminder_time": {"description": "The exact date and time (ISO 8601 format, including timezone, e.g., ''2025-05-10T14:30:00+02:00'') when the reminder should be sent.", "type": "STRING"}, "message": {"description": "The reminder message to send (e.g., ''Take your medication'', ''Call mom'', ''Submit the report'').", "type": "STRING"}, "follow_up": {"description": "If true, will automatically send follow-up reminders if the user doesn''t respond. Use for important reminders or when user says ''don''t let me forget''.", "type": "BOOLEAN"}, "follow_up_interval": {"description": "Time between follow-up reminders (e.g., ''30 minutes'', ''1 hour''). Only used if follow_up is true.", "type": "STRING"}, "max_follow_ups": {"description": "Maximum number of follow-up reminders to send. Only used if follow_up is true.", "type": "INTEGER"}}, "required": ["reminder_time", "message"], "type": "OBJECT"}}, {"description": "Schedule a future trigger for yourself (the assistant) to continue processing or check on a task at a specified time. Use this for continuing work or checking task status, NOT for reminders. For reminders, use schedule_reminder instead.\n\nReturns: A string indicating the result. On success, returns ''OK. Callback scheduled for [time].''. On invalid time format or past time, returns ''Error: Invalid callback time provided. Ensure it''s a future ISO 8601 datetime with timezone. [details]''. On other errors, returns ''Error: Failed to schedule the callback.''.", "name": "schedule_future_callback", "parameters": {"properties": {"callback_time": {"description": "The exact date and time (ISO 8601 format, including timezone, e.g., ''2025-05-10T14:30:00+02:00'') when the callback should be triggered.", "type": "STRING"}, "context": {"description": "The specific instructions or information you need to remember for the callback (e.g., ''Check if the download finished'', ''Continue analyzing the data'').", "type": "STRING"}}, "required": ["callback_time", "context"], "type": "OBJECT"}}, {"description": "Schedule a recurring LLM callback that will trigger repeatedly based on a recurrence rule (RRULE string). Use this for tasks that need to happen on a regular schedule, like daily briefings, weekly check-ins, or periodic reminders. IMPORTANT: Each recurring task creates individual callback instances that can be managed using list_pending_callbacks, modify_pending_callback, and cancel_pending_callback tools. To stop a recurring task entirely, you must cancel all its pending instances.\n\nReturns: A string indicating the result. On success, returns ''OK. Recurring callback [task_id] scheduled starting [time] with rule [rule].''. On invalid arguments (RRULE format, past time), returns ''Error: Invalid arguments provided. [details]''. On other errors, returns ''Error: Failed to schedule the recurring task.''.", "name": "schedule_recurring_task", "parameters": {"properties": {"initial_schedule_time": {"description": "The exact date and time (ISO 8601 format with timezone, e.g., ''2025-05-15T08:00:00+00:00'') when the *first* instance of the callback should run.", "type": "STRING"}, "recurrence_rule": {"description": "An RRULE string defining the recurrence schedule according to RFC 5545 (e.g., ''FREQ=DAILY;INTERVAL=1;BYHOUR=8;BYMINUTE=0'' for 8:00 AM daily, ''FREQ=WEEKLY;BYDAY=MO'' for every Monday).", "type": "STRING"}, "callback_context": {"description": "The context or instructions for the LLM when the callback triggers (e.g., ''Send a morning briefing with today''s calendar events and weather'', ''Check if any important emails arrived'').", "type": "STRING"}, "max_retries": {"description": "Optional. Maximum number of retries for each instance if it fails (default: 3).", "type": "INTEGER"}, "description": {"description": "Optional. A short, URL-safe description to help identify the task (e.g., ''daily_brief'', ''weekly_summary'').", "type": "STRING"}}, "required": ["initial_schedule_time", "recurrence_rule", "callback_context"], "type": "OBJECT"}}, {"description": "Lists all pending LLM callback tasks for the current conversation, including:\n- One-time callbacks from schedule_future_callback\n- Reminder callbacks from schedule_reminder\n- Individual instances of recurring tasks from schedule_recurring_task\nReturns task IDs, scheduled times, and context for each pending callback.\n\nReturns: A formatted string listing pending callbacks. If callbacks exist, returns ''Pending LLM callbacks:'' followed by entries with ''- Task ID: [id]\n  Scheduled At: [time]\n  Context: [context preview]''. If no callbacks found, returns ''No pending LLM callbacks found for this conversation.''. On error, returns ''Error: Failed to list pending callbacks. [details]''.", "name": "list_pending_callbacks", "parameters": {"properties": {"limit": {"description": "Optional. Maximum number of pending callbacks to list (default: 5).", "type": "INTEGER"}}, "required": [], "type": "OBJECT"}}, {"description": "Modifies the scheduled time or context of a specific pending LLM callback task. You must provide the task_id of the callback to modify.\n\nReturns: A string indicating the result. On success, returns ''Callback task [task_id] modified successfully.''. If neither new_callback_time nor new_context provided, returns ''Error: You must provide either a new_callback_time or a new_context to modify.''. If task not found, returns ''Error: Callback task with ID [task_id] not found.''. If task not an LLM callback, returns ''Error: Task [task_id] is not an LLM callback task.''. If task not pending, returns ''Error: Callback task [task_id] is not pending (current status: [status]). It cannot be modified.''. If task belongs to different conversation, returns ''Error: Callback task [task_id] does not belong to this conversation. Modification denied.''. On invalid new time, returns ''Error: Invalid new_callback_time. [details]''. On other errors, returns ''Error: Failed to modify callback task. [details]''.", "name": "modify_pending_callback", "parameters": {"properties": {"task_id": {"description": "The unique ID of the LLM callback task to modify (obtained from list_pending_callbacks or when it was scheduled).", "type": "STRING"}, "new_callback_time": {"description": "Optional. The new exact date and time (ISO 8601 format, including timezone, e.g., ''2025-06-01T10:00:00-07:00'') for the callback. If omitted, the time is not changed.", "type": "STRING"}, "new_context": {"description": "Optional. The new context or instructions for the callback. If omitted, the context is not changed.", "type": "STRING"}}, "required": ["task_id"], "type": "OBJECT"}}, {"description": "Cancels a specific pending LLM callback task by its task_id. Use this to:\n- Cancel one-time future callbacks\n- Cancel scheduled reminders\n- Cancel individual instances of recurring tasks\n- Stop a recurring task by canceling all its pending instances (use list_pending_callbacks first to find them)\nNote: This cancels only the specific task instance identified by task_id.\n\nReturns: A string indicating the result. On success, returns ''Callback task [task_id] cancelled successfully.''. If task not found, returns ''Error: Callback task with ID [task_id] not found.''. If task not an LLM callback, returns ''Error: Task [task_id] is not an LLM callback task.''. If task not pending, returns ''Error: Callback task [task_id] is not pending (current status: [status]). It cannot be cancelled.''. If task belongs to different conversation, returns ''Error: Callback task [task_id] does not belong to this conversation. Cancellation denied.''. On other errors, returns ''Error: Failed to cancel callback task. [details]''.", "name": "cancel_pending_callback", "parameters": {"properties": {"task_id": {"description": "The unique ID of the LLM callback task to cancel (obtained from list_pending_callbacks or when it was scheduled).", "type": "STRING"}}, "required": ["task_id"], "type": "OBJECT"}}, {"description": "Schedule any action (wake_llm or script) to execute at a specific time. This is the general-purpose scheduling tool that complements schedule_future_callback. Use this when you need to schedule script execution or want more control over LLM callbacks.\n\nReturns: A string indicating the result. On success, returns ''OK. [action_type] action scheduled for [schedule_time]''. If invalid action_type, returns ''Error: Invalid action_type. Must be one of: [valid types]''. If wake_llm missing context, returns ''Error: wake_llm action requires ''context'' in action_config''. If script missing script_code, returns ''Error: script action requires ''script_code'' in action_config''. If schedule_time in past, returns ''Error: Schedule time must be in the future''. On invalid time format, returns ''Error: Invalid schedule_time format: [details]''. On other errors, returns ''Error: Failed to schedule action. [details]''.", "name": "schedule_action", "parameters": {"properties": {"schedule_time": {"description": "When to execute the action (ISO 8601 format with timezone, e.g., ''2025-05-10T14:30:00+02:00'')", "type": "STRING"}, "action_type": {"description": "Type of action to execute", "type": "STRING"}, "action_config": {"description": "Configuration for the action. For wake_llm: {''context'': ''message for LLM''}. For script: {''script_code'': ''Starlark code'', ''timeout'': 600}", "type": "OBJECT"}}, "required": ["schedule_time", "action_config"], "type": "OBJECT"}}, {"description": "Schedule a recurring action (wake_llm or script) using RRULE format. This tool allows scheduling scripts to run on a recurring basis, complementing schedule_recurring_task which only supports LLM callbacks.\n\nReturns: A string indicating the result. On success, returns ''OK. Recurring [action_type] action scheduled starting [start_time]'' or ''OK. Recurring [action_type] action ([task_name]) scheduled starting [start_time]'' if task_name provided. If invalid action_type, returns ''Error: Invalid action_type. Must be one of: [valid types]''. If wake_llm missing context, returns ''Error: wake_llm action requires ''context'' in action_config''. If script missing script_code, returns ''Error: script action requires ''script_code'' in action_config''. If start_time in past, returns ''Error: Start time must be in the future''. On invalid time format, returns ''Error: Invalid start_time format: [details]''. On invalid RRULE, returns ''Error: Invalid recurrence rule: [details]''. On other errors, returns ''Error: Failed to schedule recurring action. [details]''.", "name": "schedule_recurring_action", "parameters": {"properties": {"start_time": {"description": "When to start the recurring schedule (ISO 8601 format with timezone)", "type": "STRING"}, "recurrence_rule": {"description": "RRULE format string (e.g., ''FREQ=DAILY;INTERVAL=1'', ''FREQ=WEEKLY;BYDAY=MO,WE,FR'', ''FREQ=HOURLY;INTERVAL=4'')", "type": "STRING"}, "action_type": {"description": "Type of action to execute", "type": "STRING"}, "action_config": {"description": "Configuration for the action. For wake_llm: {''context'': ''message for LLM''}. For script: {''script_code'': ''Starlark code'', ''timeout'': 600}", "type": "OBJECT"}, "task_name": {"description": "Optional. A short, URL-safe description to help identify the recurring task (e.g., ''daily_weather_check'', ''hourly_metrics'')", "type": "STRING"}}, "required": ["start_time", "recurrence_rule", "action_config"], "type": "OBJECT"}}, {"description": "Search previously stored documents (emails, notes, files) using semantic and keyword matching. Returns titles and snippets of the most relevant documents.\n\nReturns: A formatted string containing search results. On success, returns ''Found relevant documents:'' followed by numbered results with Title, Source, Document ID, optional original file availability (\ud83d\udcce), Metadata, and Snippet. When original files (PDFs, images) are available, they are indicated with \ud83d\udcce symbol and file info. Use get_full_document_content to retrieve the actual file. If no results found, returns ''No relevant documents found matching the query and filters.''. On error, returns ''Error: Failed to execute document search. [error details]'' or ''Error: Query text cannot be empty.'' or ''Error: Failed to generate embedding for the query.''.", "name": "search_documents", "parameters": {"properties": {"query": {"description": "The natural language query describing the information to search for.", "type": "STRING"}, "source_types": {"description": "Optional. Filter results to only include documents from specific sources. Common sources: ''email'', ''note'', ''google_drive'', ''pdf'', ''image''. Use ONLY if you are certain about the source type, otherwise omit this filter.", "items": {"description": "", "type": "STRING"}, "type": "ARRAY"}, "embedding_types": {"description": "Optional. Filter results based on the type of content that was embedded. Common types: ''content_chunk'', ''summary'', ''title'', ''ocr_text''. Use ONLY if necessary (e.g., searching only titles), otherwise omit this filter.", "items": {"description": "", "type": "STRING"}, "type": "ARRAY"}, "limit": {"description": "Optional. Maximum number of results to return (default: 5).", "type": "INTEGER"}}, "required": ["query"], "type": "OBJECT"}}, {"description": "Retrieves the full content of a document in the best available format using its unique document ID (obtained from a previous search). Returns original file (PDF, image, etc.) when available, otherwise text content.\n\nReturns: ToolResult with file attachment when original file is available, otherwise a string containing the text content. When original file exists, returns both the file as an attachment and extracted text for context. For PDFs and images, you can analyze the file directly using your multimodal capabilities. If only text content is available, returns the full text content (raw content if available, or reconstructed from chunks). If document exists but no content available, returns ''Error: Document [id] found, but no content is available.''. If document not found, returns ''Error: Document with ID [id] not found.''. On error, returns ''Error: Failed to retrieve content for document ID [id]. [error details]''. Files larger than 20MB will fallback to text-only for performance.", "name": "get_full_document_content", "parameters": {"properties": {"document_id": {"description": "The unique identifier of the document whose full content is needed.", "type": "INTEGER"}}, "required": ["document_id"], "type": "OBJECT"}}, {"description": "Submits a document from a given URL for ingestion and indexing by the system. Use this tool if the user asks you to ''save'' a web page. The document will be fetched from the URL, its content extracted, processed, and stored to be made searchable. Provide a unique source_id for tracking this ingestion request.\n\nReturns: A string indicating the ingestion status. On success, returns ''URL submitted. Service response: [message]. Document ID: [id]. Task Enqueued: [status].''. If ingestion fails, returns ''Error submitting URL for ingestion: [message]. Details: [error details]''. If configuration missing, returns ''Error: Server configuration missing (document storage path).''. On unexpected error, returns ''Error: An unexpected error occurred while submitting the URL. [error details]''.", "name": "ingest_document_from_url", "parameters": {"properties": {"url_to_ingest": {"description": "The fully qualified URL of the document to ingest.", "type": "STRING"}, "title": {"description": "Optional. The primary title to assign to this document. If omitted, the title will be extracted automatically during the indexing process from the web page content.", "type": "STRING"}, "source_type": {"description": "A category or type for this document source, e.g., ''llm_url_ingestion'', ''user_link_submission''.", "type": "STRING"}, "source_id": {"description": "A unique identifier for this specific document within its source_type. This should be unique for each ingestion request to avoid conflicts. A UUID is a good choice if one is not readily available.", "type": "STRING"}, "metadata_json": {"description": "Optional. A JSON string representing a dictionary of additional key-value metadata to associate with the document (e.g., ''{\"category\": \"research\", \"tags\": [\"ai\", \"llm\"]}'').", "type": "STRING"}}, "required": ["url_to_ingest", "source_type", "source_id"], "type": "OBJECT"}}, {"description": "Retrieves the content of a specific user documentation file. Use this to answer questions about how the assistant works or what features it has, based on the official documentation.\nAvailable files: {available_doc_files}\n\nReturns: A string containing the file content or an error message. On success, returns the full content of the documentation file. If access denied, returns ''Error: Access denied. Invalid filename or extension [filename].'' or ''Error: Access denied. Invalid path for filename [filename].''. If file not found, returns ''Error: Documentation file [filename] not found.''. On read error, returns ''Error: Failed to read documentation file [filename]. [error details]''.", "name": "get_user_documentation_content", "parameters": {"properties": {"filename": {"description": "The exact filename of the documentation file to retrieve (e.g., ''USER_GUIDE.md''). Must end in .md or .txt.", "type": "STRING"}}, "required": ["filename"], "type": "OBJECT"}}, {"description": "Query recent events from the event system. Returns raw event data in JSON format for examining event structure and content.\n\nReturns: A JSON string containing event data as a dict. On success, returns {''events'': [array of event objects], ''count'': [number], ''hours_queried'': [hours], ''source_filter'': [source_id or null]}. Each event object contains: event_id, source_id, timestamp (ISO format), event_data (parsed JSON), triggered_listeners (array of IDs). If no events found, returns {''events'': [], ''message'': ''No events found in the last [hours] hours''}. On error, returns ''Error: Failed to query recent events. [error details]'' as a string.", "name": "query_recent_events", "parameters": {"properties": {"source_id": {"description": "Optional. Filter by event source (e.g., ''home_assistant'', ''indexing'', ''webhook'')", "type": "STRING"}, "hours": {"description": "Number of hours to look back (default: 1, max: 48)", "type": "INTEGER"}, "limit": {"description": "Maximum number of events to return (default: 10, max: 20)", "type": "INTEGER"}}, "required": [], "type": "OBJECT"}}, {"description": "Test what events would match given listener conditions. Use this before creating a listener to ensure the match conditions are correct. Returns events that would have triggered the listener.\n\nReturns: A JSON string containing test results as a dict. On success, returns {''matched_events'': [array of matching events], ''total_tested'': [number], ''matched_count'': [number], ''match_conditions'': [conditions used], ''hours_queried'': [hours], ''analysis'': [optional array of analysis messages]}. Each matched event contains: event_id, timestamp (ISO format), event_data. If no events to test, returns similar structure with ''message'' explaining no events found. If match_conditions empty, returns {''error'': ''match_conditions cannot be empty'', ''message'': ''Please provide at least one condition to test''}. When no events match and validation is available, analysis will include validation errors and suggestions. On other errors, returns {''error'': ''Failed to test event listener: [error details]'', ''match_conditions'': [conditions used]}.", "name": "test_event_listener", "parameters": {"properties": {"source": {"description": "Event source to test against (e.g., ''home_assistant'', ''indexing'')", "type": "STRING"}, "match_conditions": {"description": "Match conditions to test. Use dot notation for nested fields (e.g., {''entity_id'': ''person.andrew'', ''new_state.state'': ''Home''})", "type": "OBJECT"}, "hours": {"description": "Number of hours to look back (default: 24, max: 48)", "type": "INTEGER"}, "limit": {"description": "Maximum number of matching events to return (default: 10, max: 20)", "type": "INTEGER"}}, "required": ["source", "match_conditions"], "type": "OBJECT"}}, {"description": "Create a new automation (event-triggered or schedule-based).\n\nEvent automations trigger when specific events occur (e.g., email received, calendar event).\nSchedule automations run on a recurring schedule using RRULE format.\n\nExamples:\n- Event: \"Send me a reminder when I receive an email from work\"\n- Schedule: \"Wake me up every weekday at 7am\" (RRULE: FREQ=DAILY;BYDAY=MO,TU,WE,TH,FR)", "name": "create_automation", "parameters": {"properties": {"name": {"description": "Unique name for the automation", "type": "STRING"}, "automation_type": {"description": "Type of automation: ''event'' for event-triggered, ''schedule'' for time-based", "type": "STRING"}, "trigger_config": {"description": "Configuration for the trigger.\nFor event automations:\n  - event_source: string (e.g., ''email_received'', ''calendar_event'')\n  - event_filter: object with filtering criteria\n\nFor schedule automations:\n  - recurrence_rule: RRULE string (e.g., ''FREQ=DAILY;BYHOUR=7'')", "type": "OBJECT"}, "action_type": {"description": "Action to perform: ''wake_llm'' to notify you, ''script'' to run code", "type": "STRING"}, "action_config": {"description": "Configuration for the action.\nFor wake_llm:\n  - context: string with optional context for the LLM\n\nFor script:\n  - script_code: Python code to execute\n  - task_name: optional name for the script execution", "type": "OBJECT"}, "description": {"description": "Optional description of what this automation does", "type": "STRING"}}, "required": ["name", "automation_type", "trigger_config", "action_type", "action_config"], "type": "OBJECT"}}, {"description": "List all automations, optionally filtered by type (event/schedule) or enabled status", "name": "list_automations", "parameters": {"properties": {"automation_type": {"description": "Filter by automation type (omit to show all)", "type": "STRING"}, "enabled_only": {"description": "Only show enabled automations (default: false)", "type": "BOOLEAN"}}, "required": [], "type": "OBJECT"}}, {"description": "Get details of a specific automation by ID", "name": "get_automation", "parameters": {"properties": {"automation_id": {"description": "ID of the automation", "type": "INTEGER"}, "automation_type": {"description": "Type of automation", "type": "STRING"}}, "required": ["automation_id", "automation_type"], "type": "OBJECT"}}, {"description": "Update an existing automation''s configuration", "name": "update_automation", "parameters": {"properties": {"automation_id": {"description": "ID of the automation to update", "type": "INTEGER"}, "automation_type": {"description": "Type of automation", "type": "STRING"}, "trigger_config": {"description": "New trigger configuration (optional)", "type": "OBJECT"}, "action_config": {"description": "New action configuration (optional)", "type": "OBJECT"}, "description": {"description": "New description (optional)", "type": "STRING"}}, "required": ["automation_id", "automation_type"], "type": "OBJECT"}}, {"description": "Enable a disabled automation", "name": "enable_automation", "parameters": {"properties": {"automation_id": {"description": "ID of the automation", "type": "INTEGER"}, "automation_type": {"description": "Type of automation", "type": "STRING"}}, "required": ["automation_id", "automation_type"], "type": "OBJECT"}}, {"description": "Disable an automation temporarily (can be re-enabled later)", "name": "disable_automation", "parameters": {"properties": {"automation_id": {"description": "ID of the automation", "type": "INTEGER"}, "automation_type": {"description": "Type of automation", "type": "STRING"}}, "required": ["automation_id", "automation_type"], "type": "OBJECT"}}, {"description": "Permanently delete an automation", "name": "delete_automation", "parameters": {"properties": {"automation_id": {"description": "ID of the automation", "type": "INTEGER"}, "automation_type": {"description": "Type of automation", "type": "STRING"}}, "required": ["automation_id", "automation_type"], "type": "OBJECT"}}, {"description": "Get execution statistics and recent history for an automation", "name": "get_automation_stats", "parameters": {"properties": {"automation_id": {"description": "ID of the automation", "type": "INTEGER"}, "automation_type": {"description": "Type of automation", "type": "STRING"}}, "required": ["automation_id", "automation_type"], "type": "OBJECT"}}, {"description": "Downloads historical state data from Home Assistant as a JSON file. This tool retrieves past state changes for specified entities over a given time period, allowing analysis and manipulation of historical data.\n\nReturns: A JSON attachment containing the state history data with entity states, attributes, and timestamps. The data can be loaded and analyzed programmatically. If no entities are specified, retrieves history for all entities (may be large). On errors, returns descriptive error messages.\n\nResponse Schema:\n{\n  \"start_time\": \"ISO 8601 timestamp\",\n  \"end_time\": \"ISO 8601 timestamp\",\n  \"significant_changes_only\": boolean,\n  \"entities\": [\n    {\n      \"entity_id\": \"sensor.example\",\n      \"states\": [\n        {\n          \"state\": \"value or unavailable/unknown/null\",\n          \"attributes\": {...},\n          \"last_changed\": \"ISO 8601 timestamp\",\n          \"last_updated\": \"ISO 8601 timestamp\"\n        }\n      ]\n    }\n  ]\n}\n\nIMPORTANT: For data visualization, it''s recommended to retrieve history as an attachment first (using this tool), then pass the attachment to visualization tools. This allows the LLM to see the inferred JSON schema, making it much easier to understand the data structure and create correct visualizations. Sensor states may contain non-numeric values like ''unavailable'' or ''unknown'' that should be filtered before visualization.", "name": "download_state_history", "parameters": {"properties": {"entity_ids": {"description": "Optional list of entity IDs to retrieve history for (e.g., [''sensor.temperature'', ''light.living_room'']). If not provided, retrieves history for all entities. Be cautious with all entities as it may return a large dataset.", "items": {"description": "", "type": "STRING"}, "type": "ARRAY"}, "start_time": {"description": "Optional ISO 8601 timestamp for the start of the history period (e.g., ''2024-01-01T00:00:00Z''). If not provided, defaults to 24 hours ago.", "type": "STRING"}, "end_time": {"description": "Optional ISO 8601 timestamp for the end of the history period (e.g., ''2024-01-02T00:00:00Z''). If not provided, defaults to current time.", "type": "STRING"}, "significant_changes_only": {"description": "If true, only return significant state changes (filters out minor updates). Defaults to false.", "type": "BOOLEAN"}}, "required": [], "type": "OBJECT"}}, {"description": "Renders a Home Assistant Jinja2 template and returns the result. This tool allows you to evaluate templates using Home Assistant''s current state, including all entities, attributes, and template functions available in HA. Common uses include getting entity states, performing calculations, or formatting data using Home Assistant''s template engine.\n\nReturns: A string containing the rendered template result. On success, returns the evaluated template output as a string (empty results return ''Template rendered to empty result''). If HA not configured, returns ''Error: Home Assistant integration is not configured or available.''. If HA API not installed, returns ''Error: Home Assistant API library is not installed.''. On API error, returns ''Error: Home Assistant API error - [error details]''. On other errors, returns ''Error: Failed to render template - [error details]''.", "name": "render_home_assistant_template", "parameters": {"properties": {"template": {"description": "The Jinja2 template string to render. Can use all Home Assistant template functions and filters, such as states(), state_attr(), now(), as_timestamp(), etc. Example: ''{{ states(\"sensor.temperature\") }}''", "type": "STRING"}}, "required": ["template"], "type": "OBJECT"}}, {"description": "Retrieves a current snapshot/image from a Home Assistant camera entity. The image will be displayed to you for analysis. If no camera_entity_id is provided, returns a list of available cameras.\n\nCommon camera entities include doorbell cameras, security cameras, and webcams. Examples: camera.front_door, camera.doorbell_camera, camera.backyard_cam\n\nReturns: Captures and displays the camera image to the user when entity_id is provided. Without entity_id, returns list of available cameras. On errors, returns descriptive error messages.", "name": "get_camera_snapshot", "parameters": {"properties": {"camera_entity_id": {"description": "The Home Assistant entity ID of the camera (e.g., ''camera.front_door''). If not provided, returns a list of all available camera entities.", "type": "STRING"}}, "required": [], "type": "OBJECT"}}, {"description": "List and search Home Assistant entities by ID, name, or area. Returns entities with their IDs, friendly names, areas, and devices. Useful for discovering what sensors, lights, switches, cameras, and other entities are available in your Home Assistant setup.\n\nThe entity_id_filter parameter does substring matching, so you can search by:\n- Entity type: ''sensor'', ''light'', ''switch'', ''binary_sensor''\n- Function: ''temperature'', ''motion'', ''energy'', ''camera''\n- Specific entity: ''pool'', ''living_room'', ''garage''\n- Combined: ''sensor.pool'' finds pool sensors, ''light.living'' finds living room lights\n\nExamples:\n- list_home_assistant_entities(entity_id_filter=''temperature'') \u2192 all temperature sensors\n- list_home_assistant_entities(entity_id_filter=''light.living'') \u2192 living room lights\n- list_home_assistant_entities(area_filter=''pool'') \u2192 all pool equipment\n- list_home_assistant_entities(entity_id_filter=''motion'') \u2192 motion sensors\n\nResults are cached for 2 minutes to improve performance.", "name": "list_home_assistant_entities", "parameters": {"properties": {"entity_id_filter": {"description": "Optional case-insensitive substring to filter entity IDs. Since entity IDs follow the pattern ''domain.name'' (e.g., ''sensor.pool_temperature''), you can filter by domain (''sensor''), function (''temperature''), location (''pool''), or combinations (''sensor.pool''). Matches any part of the entity ID.", "type": "STRING"}, "area_filter": {"description": "Optional case-insensitive substring to filter by area name (e.g., ''living room'', ''pool'', ''garage'', ''bedroom''). Only returns entities assigned to areas matching this substring.", "type": "STRING"}, "max_results": {"description": "Maximum number of results to return. Defaults to 50. Maximum allowed is 200. Use filters to narrow results if needed.", "type": "INTEGER"}}, "required": [], "type": "OBJECT"}}, {"description": "Adds a new event to the primary family calendar (requires CalDAV configuration). Can create single or recurring events. Use this to schedule appointments, reminders with duration, or block out time. IMPORTANT: Always use search_calendar_events first to check for existing similar events and avoid creating duplicates.", "name": "add_calendar_event", "parameters": {"properties": {"summary": {"description": "The title or brief summary of the event.", "type": "STRING"}, "start_time": {"description": "The start date or datetime of the event in ISO 8601 format. MUST include timezone offset (e.g., ''2025-05-20T09:00:00+02:00'' for timed event, ''2025-05-21'' for all-day).", "type": "STRING"}, "end_time": {"description": "The end date or datetime of the event in ISO 8601 format. MUST include timezone offset. For all-day events ending on May 21, use ''2025-05-22'' (one day after the last included day).", "type": "STRING"}, "description": {"description": "Optional detailed description of the event.", "type": "STRING"}, "all_day": {"description": "True for all-day events, False for timed events (default: False)", "type": "BOOLEAN"}, "recurrence_rule": {"description": "Optional iCalendar RRULE string for recurring events. Examples: ''FREQ=WEEKLY;BYDAY=MO,WE,FR'' for every Mon/Wed/Fri, ''FREQ=MONTHLY;BYMONTHDAY=15'' for 15th of each month.", "type": "STRING"}, "bypass_duplicate_check": {"description": "Set to true to bypass duplicate detection and create the event anyway. Use this if you''ve reviewed the similar events and determined this is NOT a duplicate (e.g., different doctors, different purposes). Default: false.", "type": "BOOLEAN"}}, "required": ["summary", "start_time", "end_time"], "type": "OBJECT"}}, {"description": "Searches for calendar events by summary text or within a date range. Uses semantic similarity to find related events, not just exact matches. Each result includes a similarity score. Use this to check for conflicts before adding new events, find existing events to modify/delete, or list upcoming events.", "name": "search_calendar_events", "parameters": {"properties": {"search_text": {"description": "Optional text to search for in event summaries. Uses similarity matching to find semantically related events (e.g., searching ''doctor'' finds ''Doctor appointment'', ''Dr. Smith checkup'', ''Medical visit''). Results include similarity scores (0.0-1.0).", "type": "STRING"}, "start_date": {"description": "Optional start date for the search range in ISO 8601 format (e.g., ''2025-05-20''). If not provided, searches from today.", "type": "STRING"}, "end_date": {"description": "Optional end date for the search range in ISO 8601 format. If not provided, searches up to 3 months from start date.", "type": "STRING"}}, "required": [], "type": "OBJECT"}}, {"description": "Modifies an existing calendar event. You must first use search_calendar_events to find the event''s UID and calendar_url. Leave fields as None to keep existing values.", "name": "modify_calendar_event", "parameters": {"properties": {"uid": {"description": "The unique identifier of the event to modify (obtained from search_calendar_events).", "type": "STRING"}, "calendar_url": {"description": "The calendar URL where the event is stored (obtained from search_calendar_events).", "type": "STRING"}, "new_summary": {"description": "New title for the event (optional).", "type": "STRING"}, "new_start_time": {"description": "New start time in ISO 8601 format (optional).", "type": "STRING"}, "new_end_time": {"description": "New end time in ISO 8601 format (optional).", "type": "STRING"}, "new_description": {"description": "New description for the event (optional).", "type": "STRING"}, "recurrence_rule": {"description": "Optional iCalendar RRULE string to set or update recurring pattern. Pass empty string to remove recurrence.", "type": "STRING"}}, "required": ["uid", "calendar_url"], "type": "OBJECT"}}, {"description": "Deletes a calendar event. You must first use search_calendar_events to find the event''s UID and calendar_url.", "name": "delete_calendar_event", "parameters": {"properties": {"uid": {"description": "The unique identifier of the event to delete (obtained from search_calendar_events).", "type": "STRING"}, "calendar_url": {"description": "The calendar URL where the event is stored (obtained from search_calendar_events).", "type": "STRING"}}, "required": ["uid", "calendar_url"], "type": "OBJECT"}}, {"description": "Retrieve past messages from the current conversation history. Use this if you need context from earlier in the conversation that might not be in the default short-term history window.\n\nReturns: A formatted string containing the message history with timestamps, roles, and content. Each message is formatted as ''[timestamp] Role: content''. Tool calls are shown as ''-> Called Tool: name(args) -> Response: response''. If no messages are found, returns ''No message history found matching the specified criteria.''. On error, returns ''Error: Failed to retrieve message history. [error details]''.", "name": "get_message_history", "parameters": {"properties": {"limit": {"description": "Optional. The maximum number of messages to retrieve (most recent first). Default is 10.", "type": "INTEGER"}, "max_age_hours": {"description": "Optional. Retrieve messages only up to this many hours old. Default is 24.", "type": "INTEGER"}}, "required": [], "type": "OBJECT"}}, {"description": "Sends a textual message to another known user. You MUST use their Chat ID as the target, which is provided in the ''Known users'' section of the system prompt. Optionally, you can include attachments with the message.\n\nReturns: A string indicating the result. On success, returns ''Message sent successfully to user with Chat ID [chat_id].''. If message is sent but history recording fails, returns ''Message sent to user with Chat ID [chat_id], but failed to record in history.''. On error, returns ''Error: Could not send message to Chat ID [chat_id]. Details: [error details]'', ''Error: Chat interface not available.'', or ''Error: Cannot use send_message_to_user tool to send a message to the user you are already replying to. The user will receive your final response directly in this conversation.''.", "name": "send_message_to_user", "parameters": {"properties": {"target_chat_id": {"description": "The conversation ID of the recipient. For Telegram conversations, this is the numeric Chat ID. For web conversations, this is a UUID. The ID must be from a known conversation provided in the system context.", "type": "STRING"}, "message_content": {"description": "The content of the message to send to the user.", "type": "STRING"}, "attachment_ids": {"description": "Optional list of attachment UUIDs to send along with the message. These must be accessible in the current conversation.", "items": {"description": "", "type": "STRING"}, "type": "ARRAY"}}, "required": ["target_chat_id", "message_content"], "type": "OBJECT"}}, {"description": "Retrieve metadata information about a specific attachment by its UUID. This includes details like file size, MIME type, description, source, and creation time.\n\nReturns: A JSON string containing attachment metadata including attachment_id, mime_type, description, size, source_type, source_id, conversation_id, created_at, and any additional metadata. On error, returns ''Error: [error details]''.", "name": "get_attachment_info", "parameters": {"properties": {"attachment_id": {"description": "The UUID of the attachment to retrieve information about.", "type": "STRING"}}, "required": ["attachment_id"], "type": "OBJECT"}}, {"description": "Execute a Starlark script in a sandboxed environment for automation and complex operations.\n\n**IMPORTANT: Before writing scripts, please read the scripting documentation first!**\nUse the command: `get_user_documentation_content filename=''scripting.md''`\n\n**What is Starlark?**\nStarlark is a Python-like language that LOOKS like Python but has important differences:\n\u2022 NO try/except - errors terminate the script\n\u2022 NO while loops - use for loops instead\n\u2022 NO isinstance() - use type() comparisons\n\u2022 Limited standard library\n\n**Tool Documentation:**\nTo see available tools and their parameters, ask: ''Show me the available tools''\n\n**Execution Environment:**\n\u2022 Timeout: 10 minutes maximum execution time (to allow for external API calls)\n\u2022 Sandboxed: No file system or network access\n\u2022 Deterministic: No random numbers or current time\n\n**Built-in Functions:**\n\u2022 Type conversions: bool(), int(), str(), list(), tuple(), dict()\n\u2022 Collections: len(), range(), sorted(), reversed(), enumerate(), zip()\n\u2022 Logic: all(), any(), max(), min()\n\u2022 Object inspection: type(), dir(), getattr(), hasattr()\n\u2022 Control: print(), fail()\n\u2022 JSON: json_encode(value), json_decode(string)\n\u2022 LLM Wake: wake_llm(context, include_event=True) - Request LLM attention with context (string or dict)\n\n**Family Assistant Tools:**\nAll enabled tools are available as functions. Call them directly:\n\u2022 add_or_update_note(title=''...'', content=''...'')\n\u2022 search_notes(query=''...'')\n\u2022 send_email(to=''...'', subject=''...'', body=''...'')\n\n**Note**: Tools currently return string results. For tools that return structured data\n(like lists or dicts), use json_decode() to parse the result:\n```starlark\nresult_str = search_notes(query=''TODO'')\nnotes = json_decode(result_str) if result_str != ''[]'' else []\n```\n\n**Tools API Functions:**\n\u2022 tools_list() - List all available tools with descriptions\n\u2022 tools_get(name) - Get detailed info about a specific tool\n\u2022 tools_execute(name, **kwargs) - Execute a tool by name\n\n**Attachment API Functions:**\n\u2022 attachment_get(attachment_id) - Get attachment metadata by ID\n\u2022 attachment_create(content, filename, description, mime_type) - Create new attachment\nNote: attachment_list() and attachment_send() are not available.\nScripts must receive attachment IDs from LLM context, tool results, or parameters.\n\n**Returning Attachments:**\nAttachments created by tools or attachment_create() are represented as dictionaries\nwith metadata: {\"id\": uuid, \"filename\": str, \"mime_type\": str, \"size\": int, \"description\": str}\nReturn these dicts to make attachments visible to the LLM:\n\n```starlark\n# Single attachment - last expression is returned\ndata = attachment_create(content=\"data\", filename=\"data.txt\", mime_type=\"text/plain\")\ndata  # Dict with attachment info, automatically sent to LLM\n\n# Multiple attachments - return list\nchart1 = create_chart(data1)  # Returns dict\nchart2 = create_chart(data2)  # Returns dict\n[chart1, chart2]  # Both dicts visible to LLM\n\n# Functional composition (recommended for data viz)\nchart = create_vega_chart(\n    spec=spec,\n    data_attachments=[jq_query(source, ''.[] | select(.value > 10)'')]\n)\nchart  # Returns attachment dict\n```\n\n**Example Scripts:**\n\n1. Simple note creation:\n```starlark\nresult = add_or_update_note(\n    title=''Meeting Notes'',\n    content=''Discussed project timeline''\n)\nprint(''Created note:'', result)\n```\n\n2. Conditional logic with search:\n```starlark\ndef process_todos():\n    # Search returns a JSON string, so decode it\n    result_str = search_notes(query=''TODO'')\n    notes = json_decode(result_str) if result_str and result_str != ''[]'' else []\n    \n    if len(notes) > 0:\n        print(''Found'', len(notes), ''TODO items'')\n        for note in notes:\n            print(''-'', note[''title''])\n    else:\n        print(''No TODO items found'')\n    return notes\n\n# Call the function\nprocess_todos()\n```\n\n3. Complex automation:\n```starlark\ndef create_project_summary():\n    # Search for notes, create summary, send email\n    result_str = search_notes(query=''Project Alpha'')\n    project_notes = json_decode(result_str) if result_str and result_str != ''[]'' else []\n    \n    summary = ''Project Alpha Summary:\\n\\n''\n    for note in project_notes:\n        summary += ''- '' + note[''title''] + ''\\n''\n    \n    if len(project_notes) > 0:\n        add_or_update_note(\n            title=''Project Alpha Summary'',\n            content=summary\n        )\n        result = send_email(\n            to=''team@example.com'',\n            subject=''Weekly Project Summary'',\n            body=summary\n        )\n        return {''notes_found'': len(project_notes), ''email_result'': result}\n    else:\n        return {''notes_found'': 0, ''email_result'': ''No notes to summarize''}\n\n# Execute the function\ncreate_project_summary()\n```\n\n4. Working with user attachments (attachment ID provided by LLM):\n```starlark\n# Attachment ID passed to script by LLM based on conversation context\n# Example: LLM calls execute_script with attachment_id parameter\ndef process_user_attachment(attachment_id):\n    # Get attachment details\n    attachment_info = attachment_get(attachment_id)\n    \n    if attachment_info:\n        print(''Processing:'', attachment_info[''description''])\n        \n        # Process the attachment with a tool (ID auto-converted to content)\n        if ''image'' in attachment_info[''mime_type'']:\n            analysis = tools_execute(''analyze_image'', image_data=attachment_id)\n            # Send results back to user via LLM tools\n            wake_llm({''message'': ''Analysis: '' + analysis, ''attachments'': [attachment_id]})\n        else:\n            # Use attach_to_response LLM tool to send attachment back\n            tools_execute(''attach_to_response'', attachment_ids=[attachment_id])\n    else:\n        print(''Attachment not found or not accessible'')\n\n# Call with attachment ID from LLM context\n# process_user_attachment(''uuid-from-llm-context'')\n```\n\n5. Data visualization with automatic attachment propagation:\n```starlark\n# Create a chart - attachment automatically returns to LLM\nspec = {\n  ''$schema'': ''https://vega.github.io/schema/vega-lite/v5.json'',\n  ''data'': {''name'': ''sensor_data''},\n  ''mark'': ''line'',\n  ''encoding'': {\n    ''x'': {''field'': ''timestamp'', ''type'': ''temporal''},\n    ''y'': {''field'': ''temperature'', ''type'': ''quantitative''}\n  }\n}\n\n# Chart is automatically visible - no need for attach_to_response!\ncreate_vega_chart(\n  spec=json_encode(spec),\n  data_attachments=[sensor_attachment_id],\n  title=''Temperature Over Time''\n)\n```\n\n6. Multi-chart dashboard:\n```starlark\n# Create multiple related charts\ntemp_spec = {''$schema'': ''...'', ''mark'': ''line'', ...}\nhumidity_spec = {''$schema'': ''...'', ''mark'': ''area'', ...}\n\ntemp_chart = create_vega_chart(spec=json_encode(temp_spec), data_attachments=[data])\nhumidity_chart = create_vega_chart(spec=json_encode(humidity_spec), data_attachments=[data])\n\n# Both charts automatically visible to LLM\n[temp_chart, humidity_chart]\n```\n\n**Language Differences from Python:**\n\u2022 No imports or modules\n\u2022 No classes (only functions and structs)\n\u2022 No while loops (use for loops with range)\n\u2022 No exceptions (use fail() to stop with error)\n\u2022 No set literals (use dict keys as workaround)\n\u2022 Strings are immutable\n\u2022 Integer division with // (not /)\n\u2022 **Important**: if/else statements can only be used inside functions, not at top level\n", "name": "execute_script", "parameters": {"properties": {"script": {"description": "The Starlark script code to execute. Must be valid Starlark syntax.\n\nThe script can:\n\u2022 Define variables and functions\n\u2022 Use control flow (if/else, for loops)\n\u2022 Call any available Family Assistant tool\n\u2022 Process and transform data\n\u2022 Print output for debugging\n\u2022 Return a value (the last expression is returned)\n\nScripts should be self-contained and handle errors gracefully.\n\n**Wake LLM Contexts:**\nIf the script calls wake_llm(), the contexts will be included in the response.\nThis allows the LLM to receive and process wake requests from scripts.\n\n**Return Values:**\nReturns a string containing the script execution result:\n\u2022 On success with return value: ''Script result: [value]'' or for dict/list: ''Script result:\\n[JSON formatted]''\n\u2022 On success without return: ''Script executed successfully with no return value.''\n\u2022 If wake_llm() called: Also includes ''--- Wake LLM Contexts ---'' section with context details\n\u2022 On syntax error: ''Error: Syntax error in script [at line N]: [details]''\n\u2022 On timeout: ''Error: Script execution timed out after [N] seconds''\n\u2022 On execution error: ''Error: Script execution failed: [details]''\n\u2022 On unexpected error: ''Error: Unexpected error executing script: [details]''", "type": "STRING"}, "globals": {"description": "Optional dictionary of global variables to inject into the script.\n\nThese variables will be available in the script''s global scope.\nUseful for passing configuration, data, or context to the script.\n\nExample:\n{\n  \"user_email\": \"john@example.com\",\n  \"project_id\": 123,\n  \"tags\": [\"important\", \"urgent\"]\n}\n\nThese can then be used in the script as regular variables.", "type": "OBJECT"}}, "required": ["script"], "type": "OBJECT"}}, {"description": "Attach files/images to your current response being sent to the user. The attachments will be sent along with your text response. Only use this with attachment IDs that are accessible in the current conversation.", "name": "attach_to_response", "parameters": {"properties": {"attachment_ids": {"description": "List of attachment IDs to include with this response", "items": {"description": "UUID of an attachment", "type": "STRING"}, "type": "ARRAY"}}, "required": ["attachment_ids"], "type": "OBJECT"}}, {"description": "Draw colored rectangles or circles to highlight regions on an image. Useful for marking objects, areas of interest, or annotations. Creates and displays a new image with the highlighted regions.\n\nBounding box coordinates are in normalized [0, 1000] format (Gemini object detection format). Format is [y_min, x_min, y_max, x_max] where coordinates are normalized to 0-1000.\n\nExample region format:\n{\n  \"box\": [200, 100, 400, 300],\n  \"label\": \"chicken\",\n  \"color\": \"red\"\n}\n\nNote: thickness is automatically scaled to 1% of image size if not specified.", "name": "highlight_image", "parameters": {"properties": {"image_attachment_id": {"description": "The UUID of the image attachment to highlight regions on. Must be an existing image attachment from the current conversation.", "type": "STRING"}, "regions": {"description": "List of regions to highlight on the image. Each region is a bounding box with optional styling.", "items": {"description": "", "type": "OBJECT"}, "type": "ARRAY"}}, "required": ["image_attachment_id", "regions"], "type": "OBJECT"}}, {"description": "Generate and display a new image from text description using AI", "name": "generate_image", "parameters": {"properties": {"prompt": {"description": "Detailed description of the image to generate", "type": "STRING"}, "style": {"description": "Style of the generated image", "type": "STRING"}}, "required": ["prompt"], "type": "OBJECT"}}, {"description": "Transform and display an existing image based on text instruction. Works for editing (remove objects), styling (make it look like a painting), or variations (same scene at night).", "name": "transform_image", "parameters": {"properties": {"image": {"description": "UUID of the attachment. The image to transform", "type": "STRING"}, "instruction": {"description": "Natural language instruction for how to transform the image", "type": "STRING"}}, "required": ["image", "instruction"], "type": "OBJECT"}}, {"description": "Create a data visualization from a Vega or Vega-Lite specification and return it as a PNG image. The LLM provides the spec and optional data (either as direct data structures or attachments).", "name": "create_vega_chart", "parameters": {"properties": {"spec": {"description": "Vega or Vega-Lite specification as a JSON string. Use Vega-Lite for simpler charts (recommended). The spec should include the data inline or use named datasets that will be populated from data or data_attachments.", "type": "STRING"}, "data_attachments": {"description": "Optional list of attachment IDs containing CSV or JSON data files to use in the visualization. Each attachment should be referenced by name in the spec''s data field. Use this for file-based data.", "items": {"description": "UUID of an attachment", "type": "STRING"}, "type": "ARRAY"}, "data": {"description": "Optional data as a direct object. If a dict with string keys, treated as named datasets (e.g., {''temps'': [...], ''humidity'': [...]}). If a list or other structure, automatically assigned to a default dataset named ''data'' - your Vega spec MUST reference it using {\"name\": \"data\"}. Use this for computed data from other tools like jq_query.", "type": "OBJECT"}, "title": {"description": "Optional title for the chart that will be shown to the user", "type": "STRING"}, "scale": {"description": "Scale factor for the output PNG (default 2 for high DPI displays)", "type": "NUMBER"}, "debug": {"description": "If true, return the generated spec as JSON instead of rendering to PNG. Useful for debugging and inspecting the spec with data merged in.", "type": "BOOLEAN"}}, "required": ["spec"], "type": "OBJECT"}}, {"description": "Query JSON data from an attachment using jq syntax. Use this to explore and extract specific fields from large JSON datasets without loading the entire content into context. Returns the query result as formatted JSON.", "name": "jq_query", "parameters": {"properties": {"attachment_id": {"description": "The UUID of the attachment containing JSON data to query.", "type": "STRING"}, "jq_program": {"description": "The jq program/query to run on the JSON data. Examples: ''length'' (count items), ''.[0]'' (first item), ''map(.field)'' (extract field from all items), ''[.[0].date, .[-1].date]'' (get date range).", "type": "STRING"}}, "required": ["attachment_id", "jq_program"], "type": "OBJECT"}}, {"description": "Mock tool to simulate taking a camera snapshot. Generates and displays a mock camera image for testing workflows. This is only for testing and development purposes.", "name": "mock_camera_snapshot", "parameters": {"properties": {"entity_id": {"description": "The camera entity ID (ignored in mock implementation).", "type": "STRING"}}, "required": [], "type": "OBJECT"}}, {"description": "Mock tool to annotate an image with text overlay. This is a test/demo tool that creates a new annotated version of the image. In a real implementation, this would use image processing libraries to add text, arrows, or other annotations.", "name": "annotate_image", "parameters": {"properties": {"image_attachment_id": {"description": "The UUID of the image attachment to annotate. Must be an existing image attachment from the current conversation.", "type": "STRING"}, "annotation_text": {"description": "Text to overlay on the image as an annotation.", "type": "STRING"}, "position": {"description": "Position where to place the annotation text.", "type": "STRING"}}, "required": ["image_attachment_id"], "type": "OBJECT"}}]}], "generationConfig": {}}'
      headers:
        Content-Type:
          - application/json
        user-agent:
          - google-genai-sdk/1.38.0 gl-python/3.13.7
        x-goog-api-client:
          - google-genai-sdk/1.38.0 gl-python/3.13.7
      method: post
      uri: https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-thinking-exp:streamGenerateContent?alt=sse
    response:
      body:
        string: "data: {\"candidates\": [{\"content\": {\"parts\": [{\"functionCall\": {\"name\": \"execute_script\",\"args\": {\"script\": \"1 + 1\"}},\"thoughtSignature\": \"CiQB0e2Kb7YrKUba37TK1aGHIjJFfOp3ymYVM4kXV0n6+9Q/KYsKZwHR7Ypv8lqq0FA4WIGN2kL7Zz0d67CTdGKLe4Q8e0RsbN5uzdVJnfl2wpqUlQPpdkcHNngXlcYLAyDyAsBddKDL9yWPGytahgeezvfWuFX+QhdKEPOBn7LhQGsNTsjsMEEUhl6U+AYKrQEB0e2Kb5PmLfSMUzbY4v94sbKk5pCpk6EugUH0mkzvYbiRAk+ta8hc4NfAsHq4pSaDhjYXDliPbztd18bnemKpZpJ7UsfCvi8r7jcM02ddrundV+b89lSQu5+BuLvTTU1/Zut5aRtNSOJOWwrljmohr8/S1DIrSRcQM8qgHP9bJqU+xb8d/oA9Er970KCDZODtBkDRuaOvLGLOGZETTTH8jo4bbzC4VXRH/1bxDA==\"}],\"role\": \"model\"},\"finishReason\": \"STOP\",\"index\": 0,\"finishMessage\": \"Model generated function call(s).\"}],\"usageMetadata\": {\"promptTokenCount\": 14125,\"candidatesTokenCount\": 18,\"totalTokenCount\": 14203,\"cachedContentTokenCount\": 13927,\"promptTokensDetails\": [{\"modality\": \"TEXT\",\"tokenCount\": 14125}],\"cacheTokensDetails\": [{\"modality\": \"TEXT\",\"tokenCount\": 13927}],\"thoughtsTokenCount\": 60},\"modelVersion\": \"gemini-2.0-flash-thinking-exp-01-21\",\"responseId\": \"UrkdabfJCf_WvdIPm53psAk\"}\r\n\r\n"
      headers:
        Alt-Svc:
          - h3=":443"; ma=2592000,h3-29=":443"; ma=2592000
        Content-Disposition:
          - attachment
        Content-Type:
          - text/event-stream
        Date:
          - Wed, 19 Nov 2025 12:34:26 GMT
        Server:
          - scaffolding on HTTPServer2
        Server-Timing:
          - gfet4t7; dur=1160
        Transfer-Encoding:
          - chunked
        Vary:
          - Origin
          - X-Origin
          - Referer
        X-Content-Type-Options:
          - nosniff
        X-Frame-Options:
          - SAMEORIGIN
        X-XSS-Protection:
          - '0'
      status:
        code: 200
        message: OK
  - request:
      body: '{"prompt":"use Python to calculate 1 + 1"}'
      headers:
        accept:
          - '*/*'
        accept-encoding:
          - gzip, deflate
        connection:
          - keep-alive
        content-length:
          - '42'
        content-type:
          - application/json
        host:
          - test
        user-agent:
          - python-httpx/0.28.1
      method: POST
      uri: http://test/api/v1/chat/send_message
    response:
      body:
        string: '{"detail":"Error processing request: Traceback (most recent call last):\n  File \"/workspace/main/src/family_assistant/processing.py\", line 2027, in handle_chat_interaction\n    ) = await self.process_message(\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    ...<10 lines>...\n    )\n    ^\n  File \"/workspace/main/src/family_assistant/processing.py\", line 399, in process_message\n    async for event, message_dict in self.process_message_stream(\n    ...<24 lines>...\n                final_attachment_ids = event.metadata[\"attachment_ids\"]\n  File \"/workspace/main/src/family_assistant/processing.py\", line 679, in process_message_stream\n    llm_context_assistant_message = AssistantMessage(\n        role=\"assistant\",\n        content=final_content,\n        tool_calls=tool_call_items or None,\n    )\n  File \"/workspace/main/.venv/lib/python3.13/site-packages/pydantic/main.py\", line 193, in __init__\n    self.__pydantic_validator__.validate_python(data, self_instance=self)\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^\npydantic_core._pydantic_core.ValidationError: 1 validation error for AssistantMessage\ntool_calls\n  Value error, Assistant message must have content or tool_calls [type=value_error, input_value=None, input_type=NoneType]\n    For further information visit https://errors.pydantic.dev/2.8/v/value_error\n"}'
      headers:
        content-length:
          - '1369'
        content-type:
          - application/json
      status:
        code: 500
        message: Internal Server Error
version: 1
